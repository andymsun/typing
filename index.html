<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TapDance - Typing Trainer</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&family=Roboto+Mono:wght@400;500&family=Courier+Prime:wght@400&family=Source+Code+Pro:wght@400&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.7.77/Tone.js"></script>

    <style>
        /* * --- Design Philosophy ---
         * Minimalist & Focused: Clean lines, generous spacing, and a focus on the core typing experience.
         * Customizable: Users can tailor the look and feel with themes, caret styles, and more.
         * Polished & Modern: Smooth transitions and a refined color palette create a premium feel.
         */
        :root {
            --bg-primary: #111827;      /* Gray 900 */
            --bg-secondary: #1f2937;    /* Gray 800 */
            --bg-tertiary: #374151;      /* Gray 700 */
            --text-primary: #f3f4f6;    /* Gray 100 */
            --text-secondary: #9ca3af;  /* Gray 400 */
            --text-muted: #4b5563;      /* Gray 600 */
            --accent-color: #BEB05B;      /* Default Gold/Yellow Accent */
            --border-color: #374151;    /* Gray 700 */
            --correct-color: var(--accent-color);
            --incorrect-color: #f87171;  /* Red 400 */

            --main-font: 'Roboto Mono', monospace;
            --ui-font: 'Inter', sans-serif;
            --key-unit-width: 2.25rem; /* New smaller default size */
            --caret-transition-speed: 0.1s;
        }

        /* --- Theme Definitions --- */
        body[data-theme="latte"] {
            --bg-primary: #eff1f5;
            --bg-secondary: #e6e9ef;
            --bg-tertiary: #dce0e8;
            --text-primary: #4c4f69;
            --text-secondary: #6c6f85;
            --text-muted: #9ca0b0;
            --accent-color: #1e66f5; /* Blue */
            --border-color: #ccd0da;
            --incorrect-color: #d20f39; /* Red */
        }
        
        body[data-theme="ocean"] {
            --bg-primary: #0b1e3a;
            --bg-secondary: #132d57;
            --bg-tertiary: #1f4287;
            --text-primary: #eff1f5;
            --text-secondary: #a6b1e1;
            --text-muted: #5269a3;
            --accent-color: #89e0ff;
            --border-color: #1f4287;
            --incorrect-color: #ff6b6b;
        }

        body[data-theme="matrix"] {
            --bg-primary: #000000;
            --bg-secondary: #0D0D0D;
            --bg-tertiary: #1A1A1A;
            --text-primary: #00FF41;
            --text-secondary: #00b32d;
            --text-muted: #006419;
            --accent-color: #00FF41;
            --border-color: #1A1A1A;
            --incorrect-color: #FF0000;
        }

        body[data-theme="dracula"] {
            --bg-primary: #282a36;
            --bg-secondary: #44475a;
            --bg-tertiary: #6272a4;
            --text-primary: #f8f8f2;
            --text-secondary: #bd93f9;
            --text-muted: #6272a4;
            --accent-color: #ff79c6;
            --border-color: #44475a;
            --incorrect-color: #ff5555;
        }

        body[data-theme="sunset"] {
            --bg-primary: #2a273f;
            --bg-secondary: #4f3a65;
            --bg-tertiary: #754f7d;
            --text-primary: #f8f8f2;
            --text-secondary: #e0d2f7;
            --text-muted: #9d8df1;
            --accent-color: #ff8b94;
            --border-color: #4f3a65;
            --incorrect-color: #ff5555;
        }

        body[data-theme="forest"] {
            --bg-primary: #2a3d34;
            --bg-secondary: #3e5246;
            --bg-tertiary: #5f7464;
            --text-primary: #e0e0e0;
            --text-secondary: #c0c0c0;
            --text-muted: #8a9e91;
            --accent-color: #aacc88;
            --border-color: #3e5246;
            --incorrect-color: #e87d7d;
        }

        body[data-theme="deepwoken"] {
            --bg-primary: #1a1d1a;
            --bg-secondary: #292e29;
            --bg-tertiary: #3a3f3a;
            --text-primary: #e0e0e0;
            --text-secondary: #a0a0a0;
            --text-muted: #6b706b;
            --accent-color: #e0e0e0;
            --border-color: #292e29;
            --incorrect-color: #b33a3a;
        }

        * { margin: 0; padding: 0; box-sizing: border-box; }

        html, body {
            height: 100%;
            width: 100%;
            overflow: hidden;
        }

        body {
            font-family: var(--ui-font);
            background-color: var(--bg-primary);
            color: var(--text-primary);
            display: flex;
            justify-content: center;
            align-items: center;
            transition: background-color 0.3s ease;
        }

        .container {
            width: 100%;
            height: 100%;
            padding: 2rem;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            align-items: center;
            gap: 2rem;
        }

        /* --- HEADER / SETTINGS --- */
        .header {
            position: absolute;
            top: 2rem;
            left: 2rem;
            right: 2rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            z-index: 20;
        }
        
        .logo {
            font-weight: 600;
            font-size: 1.25rem;
            color: var(--text-secondary);
            transition: opacity 0.3s ease-in-out;
        }

        .logo.hidden {
            opacity: 0;
        }

        .settings-btn {
            background: transparent;
            border: none;
            color: var(--text-secondary);
            font-size: 1.25rem;
            width: 44px;
            height: 44px;
            border-radius: 50%;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex; justify-content: center; align-items: center;
        }
        
        .settings-btn:hover {
            color: var(--accent-color);
            background-color: var(--bg-secondary);
            transform: scale(1.1);
        }
        
        .settings-btn svg { width: 24px; height: 24px; fill: currentColor; transition: transform 0.4s ease; }
        .settings-btn.open svg { transform: rotate(30deg); }

        .settings-panel {
            display: none;
            flex-direction: column;
            gap: 1.5rem;
            position: absolute;
            top: calc(100% + 10px);
            right: 0;
            background: var(--bg-secondary);
            padding: 1.5rem;
            border-radius: 12px;
            border: 1px solid var(--border-color);
            width: 300px;
            z-index: 10;
            box-shadow: 0 15px 35px rgba(0,0,0,0.25);
        }
        
        .setting { display: flex; justify-content: space-between; align-items: center; }
        .setting label { color: var(--text-secondary); font-size: 0.9rem; font-weight: 500;}

        .setting select, .setting input[type="color"] {
            background: var(--bg-primary);
            color: var(--text-primary);
            border: 1px solid var(--border-color);
            padding: 0.5rem;
            border-radius: 6px;
            cursor: pointer;
            width: 140px;
            font-family: var(--ui-font);
        }

        #resetKeyboardSizeBtn {
            background:none; 
            border: 1px solid var(--border-color); 
            color: var(--text-secondary); 
            border-radius: 4px; 
            padding: 2px 6px; 
            cursor: pointer; 
            font-size: 0.7rem;
            transition: all 0.2s ease;
        }
        #resetKeyboardSizeBtn:hover {
            border-color: var(--accent-color);
            color: var(--accent-color);
        }
        
        /* Toggle Switch */
        .toggle-switch {
            position: relative;
            display: inline-block;
            width: 40px;
            height: 24px;
        }
        .toggle-switch input { opacity: 0; width: 0; height: 0; }
        .slider {
            position: absolute;
            cursor: pointer;
            top: 0; left: 0; right: 0; bottom: 0;
            background-color: var(--bg-tertiary);
            transition: .3s;
            border-radius: 24px;
        }
        .slider:before {
            position: absolute;
            content: "";
            height: 16px; width: 16px;
            left: 4px; bottom: 4px;
            background-color: var(--text-primary);
            transition: .3s;
            border-radius: 50%;
        }
        input:checked + .slider { background-color: var(--accent-color); }
        input:checked + .slider:before { transform: translateX(16px); }

        /* --- MAIN CONTENT --- */
        .main-content-wrapper {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            width: 100%;
            max-width: 900px;
            gap: 2rem;
            margin-top: -4rem; /* Pull content up a bit */
        }

        /* --- Stats (Results) --- */
        .stats {
            display: flex; gap: 4rem; justify-content: center;
            transition: opacity 0.3s ease, transform 0.3s ease;
            transform: translateY(20px);
            height: 60px;
        }
        .stats.hidden { opacity: 0; visibility: hidden; transform: translateY(0px); }

        .stat { text-align: center; }
        .stat-value { font-size: 2rem; font-weight: 600; color: var(--accent-color); }
        .stat-label { font-size: 0.8rem; color: var(--text-secondary); text-transform: uppercase; letter-spacing: 1px; }

        /* --- Mode Controls --- */
        .test-mode-controls {
            display: flex; align-items: center; flex-wrap: wrap; justify-content: center;
            background-color: var(--bg-secondary);
            padding: 0.5rem; border-radius: 8px; gap: 0.5rem;
            transition: all 0.3s ease;
        }
        .test-mode-controls.hidden { opacity: 0; visibility: hidden; transform: scale(0.95); }
        .mode-group { display: flex; gap: 0.5rem; align-items: center; }

        .mode-divider {
            width: 1px;
            height: 24px;
            background-color: var(--border-color);
            margin: 0 0.5rem;
        }

        .mode-btn {
            background: none; color: var(--text-secondary); border: none;
            padding: 0.5rem 1rem; border-radius: 6px; font-size: 0.9rem;
            cursor: pointer; transition: all 0.2s ease;
            display: flex; align-items: center; gap: 0.5rem;
            font-family: var(--ui-font); font-weight: 500;
        }
        .mode-btn:hover { color: var(--text-primary); background-color: var(--bg-tertiary); }
        .mode-btn.active { color: var(--bg-primary); background-color: var(--accent-color); }
        .mode-btn.active:hover { background-color: var(--accent-color); filter: brightness(1.1); }
        .mode-btn svg { width: 16px; height: 16px; fill: currentColor; }
        
        /* --- TYPING AREA --- */
        .typing-area {
            display: flex; flex-direction: column; justify-content: center;
            align-items: center; gap: 1rem; width: 100%;
        }

        /* In-Test Stats (live stats) */
        .in-test-stats {
            display: flex; gap: 2rem;
            color: var(--text-secondary);
            font-family: var(--main-font);
            font-size: 1.1rem;
            height: 24px; transition: opacity 0.3s ease;
        }
        .in-test-stats.hidden { opacity: 0; }
        .live-stat-wpm { color: var(--accent-color); font-weight: 500; }
        .live-stat-acc { font-weight: 500; }

        /* --- Text Display & Caret --- */
        .text-display {
            width: 100%; font-size: 1.8rem; line-height: 2;
            font-family: var(--main-font); overflow: hidden;
            height: 180px; /* MODIFIED: Set fixed height to prevent layout shifts */
            position: relative;
            cursor: text; /* Indicate this area is interactive */
            transition: opacity 0.3s ease;
            display: flex; /* Added for vertical centering */
            align-items: center; /* Added for vertical centering */
        }

        .text-content-wrapper { 
            position: relative;
            transition: transform 0.2s ease-out; 
            width: 100%; /* Ensure wrapper takes full width */
        }
        .text-content-wrapper.static { white-space: normal; }
        .text-content-wrapper.scroll { white-space: nowrap; }

        .char {
            position: relative;
            transition: color 0.2s ease;
            color: var(--text-muted); /* Untyped text is muted */
        }
        .char.correct { color: var(--text-primary); }
        .char.incorrect { color: var(--incorrect-color); background-color: rgba(248, 113, 113, 0.1); border-radius: 4px; }

        #caret {
            position: absolute;
            transition: left var(--caret-transition-speed) ease, top var(--caret-transition-speed) ease;
            border-radius: 2px;
            opacity: 0;
            animation: blink 1s infinite;
        }
        #caret.line { width: 2px; background-color: var(--accent-color); }
        #caret.block { background-color: var(--accent-color); opacity: 0.3 !important; animation: none; }
        #caret.underline { height: 3px; background-color: var(--accent-color); }
        
        #caret.smooth { transition: left 0.1s linear, top 0.1s linear; }

        @keyframes blink { 50% { opacity: 1; } }

        /* --- Restart Button --- */
        .restart-btn {
            background: transparent; border: none; color: var(--text-secondary);
            font-size: 1.5rem; cursor: pointer; transition: all 0.3s ease;
            margin-top: 1rem; opacity: 0; visibility: hidden;
            transform: scale(0.9); display: flex; align-items: center; justify-content: center;
            width: 50px;
            height: 0; /* Starts at 0, transitions to 50px */
            border-radius: 50%;
        }
        .restart-btn.visible { 
            opacity: 1; 
            visibility: visible; 
            height: 50px; /* Match width for a circle */
            transform: scale(1); 
        }
        
        @keyframes pulse {
            0% {
                box-shadow: 0 0 0 0 var(--accent-color);
            }
            100% {
                box-shadow: 0 0 0 15px transparent;
            }
        }

        .restart-btn:hover, .restart-btn:focus {
            color: var(--accent-color);
            transform: scale(1.1) rotate(15deg);
            outline: none;
            animation: pulse 1.5s infinite;
        }
        .restart-btn svg { width: 32px; height: 32px; fill: currentColor; }

        /* --- FOOTER / KEYBOARD --- */
        .keyboard {
            width: 100%; max-width: 900px; padding: 1rem 0;
            transition: opacity 0.3s ease, visibility 0.3s ease, height 0.3s ease;
        }
        .keyboard.hidden { opacity: 0; visibility: hidden; height: 0; padding: 0; margin: 0; overflow: hidden; }
        .keyboard-row { display: flex; justify-content: center; gap: 0.5rem; margin-bottom: 0.5rem; }
        .key-gap {
             width: calc(var(--key-unit-width) * 2);
             flex-shrink: 0;
        }
        .key {
            background-color: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-bottom-width: 3px;
            border-radius: 6px;
            height: calc(var(--key-unit-width) * 1.1);
            display: flex; align-items: center; justify-content: center;
            font-size: 0.8rem; color: var(--text-secondary);
            transition: all 0.1s ease; cursor: default;
            font-family: var(--main-font); flex-shrink: 0;
        }
        .key.pressed {
            background: var(--accent-color); color: var(--bg-primary);
            border-color: var(--accent-color);
            transform: translateY(2px);
            border-bottom-width: 1px;
        }
        .key .special-text { font-size: 0.65rem; }
        .u-100 { width: var(--key-unit-width); }
        .u-125 { width: calc(var(--key-unit-width) * 1.25); }
        .u-150 { width: calc(var(--key-unit-width) * 1.5); }
        .u-175 { width: calc(var(--key-unit-width) * 1.75); }
        .u-200 { width: calc(var(--key-unit-width) * 2.0); }
        .u-225 { width: calc(var(--key-unit-width) * 2.25); }
        .u-275 { width: calc(var(--key-unit-width) * 2.75); }
        .u-625 { width: calc(var(--key-unit-width) * 6.25); }
        
        /* --- Responsive Design --- */
        @media (max-width: 900px) {
            /* :root { --key-unit-width: 2.25rem; } */ /* Base size is now controlled by JS */
            .text-display { font-size: 1.6rem; }
        }
        @media (max-width: 768px) {
            .container { padding: 1rem; }
            .header { top: 1rem; left: 1rem; right: 1rem; }
            .main-content-wrapper { margin-top: 0; }
            :root { --key-unit-width: 1.8rem; }
            .test-mode-controls { justify-content: center; }
            .keyboard { display: none; } /* Hide keyboard on smaller screens for better experience */
        }
        @media (max-width: 480px) {
            .text-display { font-size: 1.4rem; line-height: 1.8; height: 120px; } /* MODIFIED */
            .test-mode-controls { font-size: 0.8rem; }
            .mode-btn { padding: 0.4rem 0.8rem; }
            .stats { gap: 1.5rem; }
            .stat-value { font-size: 1.5rem; }
        }

    </style>
</head>
<body data-theme="dark">
    <div class="container">
        <header class="header">
            <div class="logo">TapDance</div>
            <div class="settings-area">
                <button class="settings-btn" id="settingsBtn" aria-label="Open settings">
                     <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19.43 12.98c.04-.32.07-.64.07-.98s-.03-.66-.07-.98l2.11-1.65c.19-.15.24-.42.12-.64l-2-3.46c-.12-.22-.39-.3-.61-.22l-2.49 1c-.52-.4-1.08-.73-1.69-.98l-.38-2.65C14.46 2.18 14.25 2 14 2h-4c-.25 0-.46.18-.49.42l-.38 2.65c-.61.25-1.17.59-1.69-.98l-2.49-1c-.22-.08-.49 0-.61.22l-2 3.46c-.13.22-.07.49.12.64l2.11 1.65c-.04.32-.07.65-.07.98s.03.66.07.98l-2.11 1.65c-.19.15-.24-.42-.12.64l2 3.46c.12.22.39.3.61.22l2.49-1c.52.4 1.08.73 1.69.98l.38 2.65c.03.24.24.42.49.42h4c.25 0 .46-.18.49-.42l.38-2.65c.61-.25 1.17-.59 1.69-.98l2.49 1c.22.08.49 0 .61-.22l2-3.46c.12-.22.07-.49-.12-.64l-2.11-1.65zM12 15.5c-1.93 0-3.5-1.57-3.5-3.5s1.57-3.5 3.5-3.5 3.5 1.57 3.5 3.5-1.57 3.5-3.5 3.5z"/></svg>
                </button>
                <div class="settings-panel" id="settingsPanel">
                    <div class="setting">
                        <label for="themeSelect">Theme</label>
                        <select id="themeSelect">
                            <option value="dark">Dark</option>
                            <option value="latte">Latte</option>
                            <option value="ocean">Ocean</option>
                            <option value="matrix">Matrix</option>
                            <option value="dracula">Dracula</option>
                            <option value="sunset">Sunset</option>
                            <option value="forest">Forest</option>
                            <option value="deepwoken">Deepwoken</option>
                        </select>
                    </div>
                     <div class="setting">
                        <label for="accentColor">Accent</label>
                        <input type="color" id="accentColor" value="#BEB05B">
                    </div>
                    <div class="setting">
                        <label for="fontType">Font</label>
                        <select id="fontType">
                            <option value="'Roboto Mono', monospace">Roboto Mono</option>
                            <option value="'Source Code Pro', monospace">Source Code Pro</option>
                            <option value="'Courier Prime', monospace">Courier Prime</option>
                        </select>
                    </div>
                    <div class="setting">
                        <label for="caretStyleSelect">Caret Style</label>
                        <select id="caretStyleSelect">
                            <option value="line">Line</option>
                            <option value="block">Block</option>
                            <option value="underline">Underline</option>
                        </select>
                    </div>
                     <div class="setting">
                        <label for="textDisplayModeSelect">Text Style</label>
                        <select id="textDisplayModeSelect">
                            <option value="static">Static</option>
                            <option value="scroll-char">Scroll (Char)</option>
                            <option value="scroll-word">Scroll (Word)</option>
                        </select>
                    </div>
                    <div class="setting">
                        <label for="smoothCaretToggle">Smooth Caret</label>
                        <label class="toggle-switch">
                            <input type="checkbox" id="smoothCaretToggle" checked>
                            <span class="slider"></span>
                        </label>
                    </div>
                    <div class="setting">
                        <label for="skipWordToggle">Skip Word on Space</label>
                        <label class="toggle-switch">
                            <input type="checkbox" id="skipWordToggle">
                            <span class="slider"></span>
                        </label>
                    </div>
                    <div class="setting">
                        <label for="soundToggle">Typing Sound</label>
                         <label class="toggle-switch">
                            <input type="checkbox" id="soundToggle">
                            <span class="slider"></span>
                        </label>
                    </div>
                     <div class="setting">
                        <label for="keyboardType">On-Screen Keyboard</label>
                        <select id="keyboardType">
                            <option value="hidden">Hidden</option>
                            <option value="full">Full</option>
                            <option value="no-numrow">No Numrow</option>
                            <option value="split">Split</option>
                        </select>
                    </div>
                    <div class="setting">
                        <label for="keyboardSizeSlider">Keyboard Size</label>
                        <div style="display: flex; align-items: center; gap: 0.5rem;">
                            <input type="range" id="keyboardSizeSlider" min="1.5" max="3.5" step="0.05" style="width: 100px; cursor: pointer;">
                            <button id="resetKeyboardSizeBtn">Reset</button>
                        </div>
                    </div>
                </div>
            </div>
        </header>

        <div class="main-content-wrapper">
            <div class="stats hidden" id="stats">
                <div class="stat">
                    <div class="stat-value" id="wpm">0</div>
                    <div class="stat-label">WPM</div>
                </div>
                <div class="stat">
                    <div class="stat-value" id="accuracy">100%</div>
                    <div class="stat-label">Accuracy</div>
                </div>
                <div class="stat">
                    <div class="stat-value" id="time">0s</div>
                    <div class="stat-label">Time</div>
                </div>
            </div>
            
            <div class="test-mode-controls" id="testModeControls">
                <div class="mode-group" id="extraOptionsGroup"></div>
                <div class="mode-divider" id="modeDivider"></div>
                <div class="mode-group" id="primaryModeGroup"></div>
                <div class="mode-group" id="secondaryModeGroup"></div>
            </div>

            <div class="typing-area">
                <div class="in-test-stats hidden" id="inTestStats">
                    <span id="liveWPM" class="live-stat-wpm"></span>
                    <span id="liveAcc" class="live-stat-acc"></span>
                </div>
                <div class="text-display" id="textDisplayContainer">
                    <div class="text-content-wrapper" id="textContentWrapper">
                        <div id="caret" class="line"></div>
                        <!-- Spans are dynamically inserted here -->
                    </div>
                </div>
                <button class="restart-btn" id="restartBtn">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12,4C7.58,4 4,7.58 4,12s3.58,8 8,8 8-3.58 8-8-3.58-8-8-8z M16.5,17.9L12,15.4V9h1.5v5.5l3.8,2L16.5,17.9z"/></svg>
                </button>
            </div>
        </div>

        <div class="keyboard" id="keyboard"></div>
    </div>

<script>
// --- DOM Elements ---
const D = (id) => document.getElementById(id);
const logo = document.querySelector('.logo');
const textContentWrapper = D('textContentWrapper');
const statsContainer = D('stats');
const wpmDisplay = D('wpm');
const accuracyDisplay = D('accuracy');
const timeDisplay = D('time');
const settingsBtn = D('settingsBtn');
const settingsPanel = D('settingsPanel');
const modeControls = D('testModeControls');
const extraOptionsGroup = D('extraOptionsGroup');
const primaryModeGroup = D('primaryModeGroup');
const secondaryModeGroup = D('secondaryModeGroup');
const keyboardContainer = D('keyboard');
const restartBtn = D('restartBtn');
const inTestStats = D('inTestStats');
const liveWPMDisplay = D('liveWPM');
const liveAccDisplay = D('liveAcc');
const textDisplayContainer = D('textDisplayContainer');
const modeDivider = D('modeDivider');

// --- Settings Elements ---
const themeSelect = D('themeSelect');
const accentColorPicker = D('accentColor');
const fontTypeSelect = D('fontType');
const caretStyleSelect = D('caretStyleSelect');
const textDisplayModeSelect = D('textDisplayModeSelect');
const smoothCaretToggle = D('smoothCaretToggle');
const skipWordToggle = D('skipWordToggle');
const soundToggle = D('soundToggle');
const keyboardTypeSelect = D('keyboardType');
const keyboardSizeSlider = D('keyboardSizeSlider');
const resetKeyboardSizeBtn = D('resetKeyboardSizeBtn');

// --- Data & State ---
const wordList = ["the", "be", "to", "of", "and", "a", "in", "that", "have", "I", "it", "for", "not", "on", "with", "he", "as", "you", "do", "at", "this", "but", "his", "by", "from", "they", "we", "say", "her", "she", "or", "an", "will", "my", "one", "all", "would", "there", "their", "what", "so", "up", "out", "if", "about", "who", "get", "which", "go", "me", "when", "make", "can", "like", "time", "no", "just", "him", "know", "take", "person", "into", "year", "your", "good", "some", "could", "them", "see", "other", "than", "then", "now", "look", "only", "come", "its", "over", "think", "also", "back", "after", "use", "two", "how", "our", "work", "first", "well", "way", "even", "new", "want", "because", "any", "these", "give", "day", "most", "us"];
const punctuationList = ['.', ',', ';', "'", '?', '!'];
const layouts = {
    full: [[{t:'`',k:'Backquote',s:'u-100'},{t:'1',k:'Digit1',s:'u-100'},{t:'2',k:'Digit2',s:'u-100'},{t:'3',k:'Digit3',s:'u-100'},{t:'4',k:'Digit4',s:'u-100'},{t:'5',k:'Digit5',s:'u-100'},{t:'6',k:'Digit6',s:'u-100'},{t:'7',k:'Digit7',s:'u-100'},{t:'8',k:'Digit8',s:'u-100'},{t:'9',k:'Digit9',s:'u-100'},{t:'0',k:'Digit0',s:'u-100'},{t:'-',k:'Minus',s:'u-100'},{t:'=',k:'Equal',s:'u-100'},{t:'Backspace',k:'Backspace',s:'u-200'}],[{t:'Tab',k:'Tab',s:'u-150'},{t:'q',k:'KeyQ',s:'u-100'},{t:'w',k:'KeyW',s:'u-100'},{t:'e',k:'KeyE',s:'u-100'},{t:'r',k:'KeyR',s:'u-100'},{t:'t',k:'KeyT',s:'u-100'},{t:'y',k:'KeyY',s:'u-100'},{t:'u',k:'KeyU',s:'u-100'},{t:'i',k:'KeyI',s:'u-100'},{t:'o',k:'KeyO',s:'u-100'},{t:'p',k:'KeyP',s:'u-100'},{t:'[',k:'BracketLeft',s:'u-100'},{t:']',k:'BracketRight',s:'u-100'},{t:'\\',k:'Backslash',s:'u-150'}],[{t:'Caps Lock',k:'CapsLock',s:'u-175'},{t:'a',k:'KeyA',s:'u-100'},{t:'s',k:'KeyS',s:'u-100'},{t:'d',k:'KeyD',s:'u-100'},{t:'f',k:'KeyF',s:'u-100'},{t:'g',k:'KeyG',s:'u-100'},{t:'h',k:'KeyH',s:'u-100'},{t:'j',k:'KeyJ',s:'u-100'},{t:'k',k:'KeyK',s:'u-100'},{t:'l',k:'KeyL',s:'u-100'},{t:';',k:'Semicolon',s:'u-100'},{t:'\'',k:'Quote',s:'u-100'},{t:'Enter',k:'Enter',s:'u-225'}],[{t:'Shift',k:'ShiftLeft',s:'u-225'},{t:'z',k:'KeyZ',s:'u-100'},{t:'x',k:'KeyX',s:'u-100'},{t:'c',k:'KeyC',s:'u-100'},{t:'v',k:'KeyV',s:'u-100'},{t:'b',k:'KeyB',s:'u-100'},{t:'n',k:'KeyN',s:'u-100'},{t:'m',k:'KeyM',s:'u-100'},{t:',',k:'Comma',s:'u-100'},{t:'.',k:'Period',s:'u-100'},{t:'/',k:'Slash',s:'u-100'},{t:'Shift',k:'ShiftRight',s:'u-275'}],[{t:'Ctrl',k:'ControlLeft',s:'u-125'},{t:'Alt',k:'AltLeft',s:'u-125'},{t:' ',k:'Space',s:'u-625'},{t:'Alt',k:'AltRight',s:'u-125'},{t:'Ctrl',k:'ControlRight',s:'u-125'}]],
    'no-numrow': [[{t:'Tab',k:'Tab',s:'u-150'},{t:'q',k:'KeyQ',s:'u-100'},{t:'w',k:'KeyW',s:'u-100'},{t:'e',k:'KeyE',s:'u-100'},{t:'r',k:'KeyR',s:'u-100'},{t:'t',k:'KeyT',s:'u-100'},{t:'y',k:'KeyY',s:'u-100'},{t:'u',k:'KeyU',s:'u-100'},{t:'i',k:'KeyI',s:'u-100'},{t:'o',k:'KeyO',s:'u-100'},{t:'p',k:'KeyP',s:'u-100'},{t:'[',k:'BracketLeft',s:'u-100'},{t:']',k:'BracketRight',s:'u-100'},{t:'\\',k:'Backslash',s:'u-150'}],[{t:'Caps Lock',k:'CapsLock',s:'u-175'},{t:'a',k:'KeyA',s:'u-100'},{t:'s',k:'KeyS',s:'u-100'},{t:'d',k:'KeyD',s:'u-100'},{t:'f',k:'KeyF',s:'u-100'},{t:'g',k:'KeyG',s:'u-100'},{t:'h',k:'KeyH',s:'u-100'},{t:'j',k:'KeyJ',s:'u-100'},{t:'k',k:'KeyK',s:'u-100'},{t:'l',k:'KeyL',s:'u-100'},{t:';',k:'Semicolon',s:'u-100'},{t:'\'',k:'Quote',s:'u-100'},{t:'Enter',k:'Enter',s:'u-225'}],[{t:'Shift',k:'ShiftLeft',s:'u-225'},{t:'z',k:'KeyZ',s:'u-100'},{t:'x',k:'KeyX',s:'u-100'},{t:'c',k:'KeyC',s:'u-100'},{t:'v',k:'KeyV',s:'u-100'},{t:'b',k:'KeyB',s:'u-100'},{t:'n',k:'KeyN',s:'u-100'},{t:'m',k:'KeyM',s:'u-100'},{t:',',k:'Comma',s:'u-100'},{t:'.',k:'Period',s:'u-100'},{t:'/',k:'Slash',s:'u-100'},{t:'Shift',k:'ShiftRight',s:'u-275'}],[{t:'Ctrl',k:'ControlLeft',s:'u-125'},{t:'Alt',k:'AltLeft',s:'u-125'},{t:' ',k:'Space',s:'u-625'},{t:'Alt',k:'AltRight',s:'u-125'},{t:'Ctrl',k:'ControlRight',s:'u-125'}]],
    split: [
        [{t:'Tab',k:'Tab',s:'u-150'},{t:'q',k:'KeyQ',s:'u-100'},{t:'w',k:'KeyW',s:'u-100'},{t:'e',k:'KeyE',s:'u-100'},{t:'r',k:'KeyR',s:'u-100'},{t:'t',k:'KeyT',s:'u-100'},{t:'gap'},{t:'y',k:'KeyY',s:'u-100'},{t:'u',k:'KeyU',s:'u-100'},{t:'i',k:'KeyI',s:'u-100'},{t:'o',k:'KeyO',s:'u-100'},{t:'p',k:'KeyP',s:'u-100'},{t:'[',k:'BracketLeft',s:'u-100'},{t:']',k:'BracketRight',s:'u-100'}, {t:'\\', k:'Backslash', s:'u-150'}],
        [{t:'Caps',k:'CapsLock',s:'u-175'},{t:'a',k:'KeyA',s:'u-100'},{t:'s',k:'KeyS',s:'u-100'},{t:'d',k:'KeyD',s:'u-100'},{t:'f',k:'KeyF',s:'u-100'},{t:'g',k:'KeyG',s:'u-100'},{t:'gap'},{t:'h',k:'KeyH',s:'u-100'},{t:'j',k:'KeyJ',s:'u-100'},{t:'k',k:'KeyK',s:'u-100'},{t:'l',k:'KeyL',s:'u-100'},{t:';',k:'Semicolon',s:'u-100'},{t:'\'',k:'Quote',s:'u-100'}, {t:'Enter', k:'Enter', s:'u-225'}],
        [{t:'Shift',k:'ShiftLeft',s:'u-225'},{t:'z',k:'KeyZ',s:'u-100'},{t:'x',k:'KeyX',s:'u-100'},{t:'c',k:'KeyC',s:'u-100'},{t:'v',k:'KeyV',s:'u-100'},{t:'b',k:'KeyB',s:'u-100'},{t:'gap'},{t:'n',k:'KeyN',s:'u-100'},{t:'m',k:'KeyM',s:'u-100'},{t:',',k:'Comma',s:'u-100'},{t:'.',k:'Period',s:'u-100'},{t:'/',k:'Slash',s:'u-100'},{t:'Shift',k:'ShiftRight',s:'u-275'}],
        [{t:'Ctrl',k:'ControlLeft',s:'u-125'},{t:'Alt',k:'AltLeft',s:'u-125'},{t:' ',s:'u-275',k:'Space'},{t:'gap'},{t:' ',s:'u-275',k:'Space'},{t:'Alt',k:'AltRight',s:'u-125'},{t:'Ctrl',k:'ControlRight',s:'u-125'}]
    ]
};
const modeOptions = { time: [15, 30, 60, 120], words: [10, 25, 50, 100], quote: ['short', 'medium', 'long'], zen: [] };

let keyMap = {};
let originalText = '';
let typedText = '';
let isTestActive = false;
let isTestComplete = false;
let startTime = null;
let lastTypedTime = null;
let statTimer = null;
let inactivityTimer = null;
let totalCharsTyped = 0;
let totalErrors = 0;
let justSkipped = false;
let lastSkipInfo = null;

let testConfig = {
    mode: 'words', value: 25,
    includePunctuation: false, includeNumbers: false,
};
let settings = {
    theme: 'dark', accent: '#BEB05B', font: "'Roboto Mono', monospace",
    caretStyle: 'line', smoothCaret: true, skipWordOnSpace: true, sound: false, keyboard: 'hidden',
    keyboardSize: 2.25, textDisplayMode: 'static',
};

// --- Sound Engine ---
let synth;
const setupSound = () => {
    if (window.Tone && !synth) {
        synth = new Tone.Synth({
            oscillator: { type: 'sine' },
            envelope: { attack: 0.005, decay: 0.1, sustain: 0.05, release: 0.1, },
        }).toDestination();
    }
};
const playKeySound = () => settings.sound && synth && synth.triggerAttackRelease('C5', '8n');
const playErrorSound = () => settings.sound && synth && synth.triggerAttackRelease('C4', '8n', Tone.now(), 0.6);

// --- Inactivity & Pause Logic ---
const pauseTest = () => {
    if (!isTestActive) return;
    isTestActive = false; // This effectively pauses the test state
    clearInterval(statTimer);
    clearTimeout(inactivityTimer);
    inactivityTimer = null;

    // Show UI elements that are hidden during a test
    modeControls.classList.remove('hidden');
    logo.classList.remove('hidden');
    restartBtn.classList.add('visible');
    textDisplayContainer.style.opacity = '0.5'; // Dim the text to indicate pause
    requestAnimationFrame(() => {
        restartBtn.focus();
    });
};

const resetInactivityTimer = () => {
    clearTimeout(inactivityTimer);
    if (isTestActive) {
        inactivityTimer = setTimeout(pauseTest, 3000); // 3-second timeout
    }
};


// --- Core Test Logic ---
const generateText = () => {
    let newText = '';
    const { mode, value } = testConfig;
    if (mode === 'time') newText = generateWords(150);
    else if (mode === 'words') newText = generateWords(value);
    else if (mode === 'zen') newText = generateWords(300);
    else if (mode === 'quote') {
        const quotes = { short: "To be or not to be.", medium: "The quick brown fox jumps over the lazy dog.", long: "Success is not final, failure is not fatal: it is the courage to continue that counts."};
        newText = quotes[value] || quotes.medium;
    }
    return newText;
};

const generateWords = (count) => {
    let words = Array.from({ length: count }, () => wordList[Math.floor(Math.random() * wordList.length)]);
    if (testConfig.includePunctuation) {
        words = words.map((word, i) => (Math.random() < 0.2 && i < words.length - 1) ? word + punctuationList[Math.floor(Math.random() * punctuationList.length)] : word);
    }
    if (testConfig.includeNumbers) {
        for (let i = 0; i < count * 0.15; i++) {
            words.splice(Math.floor(Math.random() * words.length), 0, Math.floor(Math.random() * 1000).toString());
        }
    }
    return words.join(' ');
};

const startTest = () => {
    resetTest();
    originalText = generateText();
    renderText();
};

const resetTest = () => {
    if (statTimer) clearInterval(statTimer);
    clearTimeout(inactivityTimer);
    isTestActive = false;
    isTestComplete = false;
    originalText = '';
    typedText = '';
    startTime = null;
    lastTypedTime = null;
    statTimer = null;
    inactivityTimer = null;
    totalCharsTyped = 0;
    totalErrors = 0;
    justSkipped = false;
    lastSkipInfo = null;


    logo.classList.remove('hidden');
    textDisplayContainer.style.opacity = '1';
    // Clear previous text, keeping the caret
    textContentWrapper.querySelectorAll('.char').forEach(c => c.remove());
    
    statsContainer.classList.add('hidden');
    inTestStats.classList.add('hidden');
    modeControls.classList.remove('hidden');
    restartBtn.classList.remove('visible');
    D('caret').style.opacity = '1';
    liveWPMDisplay.textContent = '';
    liveAccDisplay.textContent = '';
    textContentWrapper.style.transform = 'translate(0, 0)';
    updateTextAndCaret();
};

const completeTest = () => {
    if (statTimer) clearInterval(statTimer);
    clearTimeout(inactivityTimer);
    updateStats(true); // Final update
    isTestActive = false;
    isTestComplete = true;
    logo.classList.remove('hidden');
    modeControls.classList.remove('hidden');
    restartBtn.classList.add('visible');
    statsContainer.classList.remove('hidden');
    inTestStats.classList.add('hidden');
    textDisplayContainer.style.opacity = '1';
    D('caret').style.opacity = '0';
    setTimeout(() => restartBtn.focus(), 100);
};

// --- Rendering & UI Updates ---
const renderText = () => {
    // A safer way to clear previous characters while keeping the caret element
    textContentWrapper.querySelectorAll('.char').forEach(c => c.remove());

    const fragment = document.createDocumentFragment();
    originalText.split('').forEach((char, index) => {
        const charEl = document.createElement('span');
        charEl.className = 'char';
        charEl.textContent = char;
        if (index < typedText.length) {
            charEl.classList.add(char === typedText[index] ? 'correct' : 'incorrect');
        }
        fragment.appendChild(charEl);
    });
    textContentWrapper.appendChild(fragment);
    updateTextAndCaret();
};

const updateTextAndCaret = () => {
    const caret = D('caret');
    if (!caret) return; // Guard against null caret
    
    // Apply caret style classes
    caret.className = 'caret'; // Reset classes first
    caret.classList.add(settings.caretStyle);
    if (settings.smoothCaret) caret.classList.add('smooth');


    textContentWrapper.className = 'text-content-wrapper';
    if (settings.textDisplayMode === 'static') {
        textContentWrapper.classList.add('static');
    } else {
        textContentWrapper.classList.add('scroll');
    }
    
    const allChars = textContentWrapper.querySelectorAll('.char');
    let targetChar = allChars[typedText.length];

    // --- Caret Positioning ---
    if (typedText.length >= originalText.length && allChars.length > 0) {
        targetChar = allChars[originalText.length - 1];
        if (targetChar) { 
            caret.style.left = `${targetChar.offsetLeft + targetChar.offsetWidth}px`;
            caret.style.top = `${targetChar.offsetTop}px`;
        }
    } else if (targetChar) {
        caret.style.left = `${targetChar.offsetLeft}px`;
        caret.style.top = `${targetChar.offsetTop}px`;
    } else if (allChars.length > 0) { // Position at the start if no text typed
        caret.style.left = `${allChars[0].offsetLeft}px`;
        caret.style.top = `${allChars[0].offsetTop}px`;
    } else { // Fallback for empty text
        caret.style.left = '0px';
        caret.style.top = '0px';
    }
    
    const charHeight = targetChar ? targetChar.offsetHeight : (parseFloat(getComputedStyle(textDisplayContainer).fontSize) * 1.2);
    caret.style.height = `${charHeight}px`;

    if (settings.caretStyle === 'underline') {
        caret.style.top = `${parseFloat(caret.style.top) + charHeight - 3}px`;
        caret.style.height = `3px`;
    }
    caret.style.width = (settings.caretStyle === 'block' && targetChar) ? `${targetChar.offsetWidth}px` : (settings.caretStyle === 'line' ? '2px' : '');


    // --- Text Scrolling ---
    if (!targetChar && allChars.length === 0) {
        textContentWrapper.style.transform = 'translate(0px, 0px)';
        return;
    }
    
    if (settings.textDisplayMode === 'static') {
        // Vertical scroll for static mode
        // This logic is now simpler because the parent container handles centering
        const scrollOffset = textContentWrapper.offsetTop;
        const targetOffset = textContentWrapper.querySelector('.char.correct:last-of-type')?.offsetTop || 0;
        
        let targetScrollY = targetOffset;
        
        // This logic remains to scroll the content up line by line as needed
        const lineHeight = targetChar?.offsetHeight || charHeight;
        const currentLineOffset = targetChar?.offsetTop || 0;
        const containerHeight = textDisplayContainer.clientHeight;
        const wrapperScrollHeight = textContentWrapper.scrollHeight;

        if (wrapperScrollHeight > containerHeight) {
            // Calculate how much to scroll to keep the current line visible
            let scrollY = currentLineOffset - lineHeight; // Aim to show the line above
            scrollY = Math.max(0, scrollY); // Don't scroll past the top
            textContentWrapper.style.transform = `translateY(-${scrollY}px)`;
        } else {
            textContentWrapper.style.transform = 'translateY(0px)';
        }

    } else {
        // Horizontal scroll logic
        const containerCenter = textDisplayContainer.clientWidth / 2;
        const caretLeft = parseFloat(caret.style.left) || 0;
        const caretWidth = caret.offsetWidth;
        const caretCenter = caretLeft + (caretWidth / 2);

        let targetX = containerCenter - caretCenter;
        textContentWrapper.style.transform = `translateX(${targetX}px)`;
    }
};


const updateStats = (isFinal = false) => {
    if (!startTime) return;
    const elapsed = (Date.now() - startTime) / 1000;
    const minutes = elapsed / 60;
    
    const correctChars = typedText.split('').filter((c, i) => c === originalText[i]).length;
    // Prevent division by zero if test is very short
    const wpm = minutes > 0.005 ? Math.round((correctChars / 5) / minutes) : 0;
    
    const accuracy = totalCharsTyped > 0 ? Math.round(((totalCharsTyped - totalErrors) / totalCharsTyped) * 100) : 100;
    
    if (isFinal || isTestComplete) {
        wpmDisplay.textContent = wpm;
        accuracyDisplay.textContent = `${accuracy}%`;
        timeDisplay.textContent = `${Math.round(elapsed)}s`;
    } else if (isTestActive) {
        liveWPMDisplay.textContent = `${wpm} WPM`;
        liveAccDisplay.textContent = `${accuracy}% ACC`;

        if (testConfig.mode === 'time') {
            const remaining = testConfig.value - elapsed;
            // The time display is now the live timer during the test.
            // Let's find a different place or way to show it if needed.
            // For now, let's keep the live WPM/Acc prominent.
            // We can show the countdown in the main `timeDisplay` since that panel is hidden.
            liveWPMDisplay.textContent = `${Math.ceil(remaining)}s | ${wpm} WPM`;

            if (remaining <= 0) completeTest();
        }
    }
};

const renderKeyboard = (layoutName) => {
    const layout = layouts[layoutName];
    if (!layout) {
        keyboardContainer.innerHTML = "";
        keyMap = {};
        return;
    }
    keyboardContainer.innerHTML = "";
    keyMap = {};
    layout.forEach(row => {
        const rowEl = document.createElement("div");
        rowEl.className = "keyboard-row";
        row.forEach(keyData => {
            if (keyData.t === 'gap') {
                const gapEl = document.createElement('div');
                gapEl.className = `key-gap`;
                rowEl.appendChild(gapEl);
                return;
            }
            const keyEl = document.createElement("div");
            keyEl.className = `key ${keyData.s}`;
            keyEl.dataset.key = keyData.k;
            if (keyData.t.length > 1) {
                keyEl.innerHTML = `<span class="special-text">${keyData.t}</span>`;
            } else {
                keyEl.textContent = keyData.t;
            }
            rowEl.appendChild(keyEl);
            keyMap[keyData.k] = keyEl;
        });
        keyboardContainer.appendChild(rowEl);
    });
};

const pressKey = (keyCode) => {
    if (settings.keyboard === 'hidden') return;
    const keyElement = keyMap[keyCode];
    if (keyElement) {
        keyElement.classList.add('pressed');
        setTimeout(() => keyElement.classList.remove('pressed'), 100);
    }
};

// --- Event Handlers ---
const handleKeyPress = (e) => {
    // When the test is finished or paused, 'Tab' can be used to focus the restart button.
    if (e.key === 'Tab') {
        e.preventDefault();
        // If the test is active, pause it. The pause function handles focusing the restart button.
        if (isTestActive) {
            pauseTest();
        } 
        // If the test is not active (i.e., it's paused or completed), just focus the restart button.
        else if (restartBtn.classList.contains('visible')) {
            restartBtn.focus();
        }
        return;
    }
    
    if (e.key === 'Escape') {
        e.preventDefault();
        if (isTestActive) {
            pauseTest();
        } else if (!isTestActive && !isTestComplete) {
            startTest(); // Restart if paused
        }
        return;
    }

    const ignoredKeys = ['Shift', 'CapsLock', 'Control', 'Alt', 'Meta', 'ArrowLeft', 'ArrowRight', 'ArrowUp', 'ArrowDown'];
    if (ignoredKeys.includes(e.key) || isTestComplete || e.ctrlKey || e.metaKey) return;
    
    if (originalText === '') return; // Don't start on empty text

    if (!isTestActive) {
        // This block handles starting or resuming a test
        if (e.key.length !== 1 && e.key !== 'Backspace') return;
        
        isTestActive = true;
        if (!startTime) { // If it's a brand new start
            startTime = Date.now();
        } else { // Resuming from a pause, adjust start time
             const pauseDuration = Date.now() - lastTypedTime;
             startTime += pauseDuration;
        }

        statTimer = setInterval(updateStats, 250);
        logo.classList.add('hidden');
        inTestStats.classList.remove('hidden');
        modeControls.classList.add('hidden');
        textDisplayContainer.style.opacity = '1';
        D('caret').style.opacity = '1';
    }
    
    lastTypedTime = Date.now();
    resetInactivityTimer();
    pressKey(e.code);
    e.preventDefault();

    if (e.key === 'Backspace') {
        if (justSkipped) {
            // Undo the word skip
            const amount = lastSkipInfo.to - lastSkipInfo.from;
            totalCharsTyped -= amount;
            totalErrors -= amount;
            typedText = typedText.substring(0, lastSkipInfo.from);
            justSkipped = false;
            lastSkipInfo = null;
        } else if (typedText.length > 0) {
            // Normal backspace
            typedText = typedText.slice(0, -1);
            justSkipped = false; 
        }
        playKeySound();
    } 
    else if (e.key.length === 1 && typedText.length < originalText.length) {
        const isSkipAttempt = settings.skipWordOnSpace && e.key === ' ' && originalText[typedText.length] !== ' ';

        if (isSkipAttempt) {
            // Handle skipping the rest of the word
            playErrorSound();
            const skipFrom = typedText.length;
            const nextSpaceIndex = originalText.indexOf(' ', skipFrom);
            
            const targetIndex = (nextSpaceIndex === -1) 
                ? originalText.length // If no more spaces, skip to the very end
                : nextSpaceIndex + 1; // Skip to the character after the space

            const numToAdvance = targetIndex - skipFrom;
            // Use a null character placeholder to mark skipped characters as incorrect
            typedText += '\0'.repeat(numToAdvance); 
            totalCharsTyped += numToAdvance;
            totalErrors += numToAdvance;
            
            lastSkipInfo = { from: skipFrom, to: targetIndex };
            justSkipped = true;
        } else {
            // Handle a normal character press
            justSkipped = false;
            totalCharsTyped++;
            
            if (e.key !== originalText[typedText.length]) {
                totalErrors++;
                playErrorSound();
            } else {
                playKeySound();
            }
            typedText += e.key;
        }
    } else {
        // Any other key press that we don't handle explicitly resets the skip flag.
        justSkipped = false;
    }

    renderText();
    updateStats(); 

    if (testConfig.mode !== 'time' && testConfig.mode !== 'zen' && typedText.length >= originalText.length) {
        completeTest();
    }
};

// --- Settings Logic ---
const applySettings = () => {
    document.body.dataset.theme = settings.theme;
    document.documentElement.style.setProperty('--accent-color', settings.accent);
    document.documentElement.style.setProperty('--main-font', settings.font);
    document.documentElement.style.setProperty('--key-unit-width', `${settings.keyboardSize}rem`);
    
    keyboardContainer.classList.toggle('hidden', settings.keyboard === 'hidden');
    if (settings.keyboard !== 'hidden') {
        renderKeyboard(settings.keyboard);
    }
    updateTextAndCaret(); // Apply text style & caret
};

const saveSettings = () => {
    localStorage.setItem('tapdance-settings', JSON.stringify(settings));
};

const loadSettings = () => {
    const saved = localStorage.getItem('tapdance-settings');
    if (saved) {
        settings = { ...settings, ...JSON.parse(saved) };
    }
    themeSelect.value = settings.theme;
    accentColorPicker.value = settings.accent;
    fontTypeSelect.value = settings.font;
    caretStyleSelect.value = settings.caretStyle;
    textDisplayModeSelect.value = settings.textDisplayMode;
    smoothCaretToggle.checked = settings.smoothCaret;
    skipWordToggle.checked = settings.skipWordOnSpace;
    soundToggle.checked = settings.sound;
    keyboardTypeSelect.value = settings.keyboard;
    keyboardSizeSlider.value = settings.keyboardSize;
    
    applySettings();
};

const initializeModeSelector = () => {
    const createBtn = (group, config, clickHandler) => {
        const btn = document.createElement('button');
        btn.className = 'mode-btn';
        if (config.isToggle) btn.classList.add('toggle-btn');
        Object.keys(config.data).forEach(key => btn.dataset[key] = config.data[key]);
        btn.innerHTML = `${config.icon || ''} ${config.name}`;
        btn.addEventListener('click', () => clickHandler(btn));
        group.appendChild(btn);
        return btn;
    };

    ['punctuation', 'numbers'].forEach(name => {
        createBtn(extraOptionsGroup, { name, isToggle: true, data: { option: name } }, (btn) => {
            btn.classList.toggle('active');
            testConfig.includePunctuation = extraOptionsGroup.querySelector('[data-option="punctuation"]').classList.contains('active');
            testConfig.includeNumbers = extraOptionsGroup.querySelector('[data-option="numbers"]').classList.contains('active');
            startTest();
        });
    });

    const primaryModes = [
        {name: 'zen', icon: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M16.89,15.73C16.58,15.93 16.27,16.14 15.97,16.34C15.05,17 14.03,17.5 12.95,17.8C11.6,18.19 10.15,18.13 8.83,17.65C7.5,17.17 6.38,16.28 5.5,15.13C4.63,13.97 4.04,12.62 3.86,11.2C3.67,9.78 3.89,8.32 4.5,7C5.12,5.68 6.13,4.55 7.43,3.83C8.73,3.11 10.27,2.83 11.75,3.05C13.23,3.27 14.6,3.98 15.73,4.9C16.13,5.2 16.5,5.54 16.84,5.88L15.42,7.3L16.84,5.88C17.7,6.76 18.29,7.9 18.48,9.15C18.67,10.4 18.46,11.68 17.9,12.85C17.34,14 16.45,15 15.37,15.66L16.89,17.18L15.47,18.6L14,17.12C13.05,17.65 11.97,18 10.85,18C9.55,18 8.33,17.61 7.33,16.88C6.33,16.15 5.58,15.13 5.19,14C4.8,12.87 4.78,11.64 5.15,10.5C5.52,9.36 6.27,8.38 7.28,7.7L8.7,9.12C8.16,9.5 7.78,10.06 7.62,10.7C7.46,11.34 7.53,12.03 7.81,12.63C8.09,13.23 8.57,13.72 9.17,13.99C9.77,14.26 10.46,14.29 11.1,14.09C11.74,13.89 12.29,13.46 12.64,12.9C12.99,12.34 13.11,11.66 12.99,11C12.87,10.34 12.52,9.75 12.03,9.34L13.45,7.92L12.03,9.34C11.45,8.83 10.76,8.47 10,8.31C9.24,8.15 8.45,8.21 7.73,8.49C7.01,8.77 6.4,9.26 5.99,9.9L4.57,8.48L5.99,9.9C5.06,10.74 4.41,11.89 4.14,13.15C3.87,14.41 4,15.71 4.5,16.85C5,18 5.86,18.96 7,19.62C8.14,20.28 9.47,20.59 10.8,20.5C12.12,20.41 13.38,19.92 14.4,19.11C15.42,18.3 16.2,17.22 16.63,16L18.05,17.42L16.63,16Z" /></svg>'},
        {name: 'time', icon: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12,2A10,10 0 0,0 2,12A10,10 0 0,0 12,22A10,10 0 0,0 22,12A10,10 0 0,0 12,2M16.2,16.2L11,13V7H12.5V12.2L17,14.9L16.2,16.2Z" /></svg>'},
        {name: 'words', icon: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M4.5,18H6V19.5H4.5V18M18,18H19.5V19.5H18V18M10.75,2.75C10.75,2.09 10.94,1.5 11.25,1C11.56,0.5 12,0.25 12.5,0.25C13,0.25 13.44,0.5 13.75,1C14.06,1.5 14.25,2.09 14.25,2.75V15.25C14.25,16.5 13.75,17.5 12.75,18.25L15.38,20.88L14.31,21.94L11.5,19.13L8.69,21.94L7.63,20.88L10.25,18.25C9.25,17.5 8.75,16.5 8.75,15.25V2.75H10.75V15.25C10.75,15.75 10.92,16.17 11.25,16.5C11.58,16.83 12,17 12.5,17C13,17 13.42,16.83 13.75,16.5C14.08,16.17 14.25,15.75 14.25,15.25V2.75Z" /></svg>'},
        {name: 'quote', icon: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M14,17H17L19,13V7H13V13H16M6,17H9L11,13V7H5V13H8L6,17Z" /></svg>'}
    ];
    primaryModes.forEach(mode => {
        const btn = createBtn(primaryModeGroup, { ...mode, data: { mode: mode.name } }, () => {
            setMode(mode.name, modeOptions[mode.name][0]);
        });
        if (mode.name === testConfig.mode) btn.classList.add('active');
    });

    updateSecondaryOptions(testConfig.mode, testConfig.value);
};

const setMode = (mode, value) => {
    document.querySelectorAll('#primaryModeGroup .mode-btn').forEach(b => b.classList.remove('active'));
    document.querySelector(`.mode-btn[data-mode="${mode}"]`)?.classList.add('active');
    testConfig.mode = mode;
    testConfig.value = value;
    updateSecondaryOptions(mode, value);
    startTest();
};

const updateSecondaryOptions = (mode, defaultValue) => {
    secondaryModeGroup.innerHTML = '';
    const options = modeOptions[mode];
    if (!options || options.length === 0) {
        modeDivider.style.display = 'none';
        return;
    }
    modeDivider.style.display = 'block';

    options.forEach(option => {
        const btn = document.createElement('button');
        btn.className = 'mode-btn';
        btn.dataset.value = option;
        btn.textContent = option;
        btn.addEventListener('click', () => {
            testConfig.value = isNaN(parseInt(option)) ? option : parseInt(option);
            document.querySelectorAll('#secondaryModeGroup .mode-btn').forEach(b => b.classList.remove('active'));
            btn.classList.add('active');
            startTest();
        });
        secondaryModeGroup.appendChild(btn);
    });
    
    const defaultBtn = secondaryModeGroup.querySelector(`[data-value="${defaultValue}"]`) || secondaryModeGroup.firstChild;
    if (defaultBtn) {
        defaultBtn.classList.add('active');
        const val = defaultBtn.dataset.value;
        testConfig.value = isNaN(parseInt(val)) ? val : parseInt(val);
    }
};

// --- Initial Setup ---
document.addEventListener('DOMContentLoaded', () => {
    loadSettings();
    initializeModeSelector();
    startTest(); // Start with a test loaded by default
    
    settingsBtn.addEventListener('click', e => {
        e.stopPropagation();
        const isOpen = settingsPanel.style.display === 'flex';
        settingsPanel.style.display = isOpen ? 'none' : 'flex';
        settingsBtn.classList.toggle('open', !isOpen);
    });
    document.addEventListener('click', e => {
        if (!settingsPanel.contains(e.target) && !settingsBtn.contains(e.target)) {
            settingsPanel.style.display = 'none';
            settingsBtn.classList.remove('open');
        }
    });
    
    themeSelect.addEventListener('change', e => { settings.theme = e.target.value; applySettings(); saveSettings(); });
    accentColorPicker.addEventListener('input', e => { settings.accent = e.target.value; document.documentElement.style.setProperty('--accent-color', settings.accent); });
    accentColorPicker.addEventListener('change', () => { saveSettings(); }); // Save on final selection
    fontTypeSelect.addEventListener('change', e => { settings.font = e.target.value; applySettings(); saveSettings(); });
    caretStyleSelect.addEventListener('change', e => { settings.caretStyle = e.target.value; applySettings(); saveSettings(); });
    textDisplayModeSelect.addEventListener('change', e => { settings.textDisplayMode = e.target.value; applySettings(); saveSettings();});
    smoothCaretToggle.addEventListener('change', e => { settings.smoothCaret = e.target.checked; applySettings(); saveSettings(); });
    skipWordToggle.addEventListener('change', e => { settings.skipWordOnSpace = e.target.checked; saveSettings(); });
    soundToggle.addEventListener('change', e => { settings.sound = e.target.checked; saveSettings(); if(settings.sound) setupSound(); });
    keyboardTypeSelect.addEventListener('change', e => { settings.keyboard = e.target.value; applySettings(); saveSettings(); });

    keyboardSizeSlider.addEventListener('input', e => {
        settings.keyboardSize = e.target.value;
        applySettings();
    });
    keyboardSizeSlider.addEventListener('change', () => { // Save on final selection
        saveSettings();
    });
    resetKeyboardSizeBtn.addEventListener('click', () => {
        settings.keyboardSize = 2.25; // Default value
        keyboardSizeSlider.value = settings.keyboardSize;
        applySettings();
        saveSettings();
    });
    
    document.addEventListener('keydown', handleKeyPress);
    restartBtn.addEventListener('click', startTest);
    textDisplayContainer.addEventListener('click', () => document.body.focus());
    window.addEventListener('resize', () => { updateTextAndCaret(); });
});
</script>
</body>
</html>
