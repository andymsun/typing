<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TypeFlow - Typing Trainer</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Courier+Prime:ital,wght@0,400;0,700;1,400;1,700&family=Roboto+Mono:ital,wght@0,100..700;1,100..700&family=Source+Code+Pro:ital,wght@0,200..900;1,200..900&display=swap" rel="stylesheet">
    <style>
        /* * --- General UI Enhancements ---
         * - Softer, more zen color palette.
         * - Increased spacing and padding for a less cluttered feel.
         * - Subtle transitions and animations for a premium experience.
         * - Replaced harsh borders with soft backgrounds and shadows.
         * - Consistent SVG icons instead of emojis.
         * - Improved typography and visual hierarchy.
        */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --accent-color: #2dd4bf; /* Teal accent */
            --bg-primary: #0f172a;   /* Slate 900 */
            --bg-secondary: #1e293b; /* Slate 800 */
            --text-primary: #e2e8f0; /* Slate 200 */
            --text-secondary: #94a3b8;/* Slate 400 */
            --text-muted: #475569;   /* Slate 600 */
            --border-color: #334155; /* Slate 700 */
            --correct-color: var(--accent-color);
            --incorrect-color: #f87171; /* Red 400 */
            --main-font: 'Roboto Mono', monospace; /* Default to a clean mono font */
            --key-unit-width: 2.5rem; 
        }

        html, body {
            height: 100%;
            width: 100%;
            overflow: hidden;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: var(--bg-primary);
            /* A more subtle gradient for a calmer background */
            background-image: radial-gradient(circle at 50% 0%, rgba(255, 255, 255, 0.05) 0%, rgba(255, 255, 255, 0) 30%);
            color: var(--text-primary);
            display: flex;
            justify-content: center;
            align-items: center;
            transition: background-color 0.3s ease;
        }

        .container {
            width: 100%;
            height: 100%;
            padding: 1.5rem;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            align-items: center;
        }

        /* --- SETTINGS --- */
        .settings-area {
            position: absolute;
            top: 1.5rem;
            right: 1.5rem;
            z-index: 20;
        }

        .settings-btn {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            color: var(--text-secondary);
            font-size: 1.25rem;
            width: 44px;
            height: 44px;
            border-radius: 50%;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        /* Removed distracting rotation, added subtle scale and color change */
        .settings-btn:hover {
            color: var(--accent-color);
            border-color: var(--accent-color);
            transform: scale(1.1);
        }
        
        .settings-btn svg {
            width: 20px;
            height: 20px;
            fill: currentColor;
            transition: transform 0.4s ease;
        }

        .settings-btn.open svg {
             transform: rotate(45deg);
        }
        
        .settings-panel {
            display: none; 
            flex-direction: column;
            gap: 1.25rem;
            position: absolute;
            top: calc(100% + 10px);
            right: 0;
            background: var(--bg-secondary);
            padding: 1.5rem;
            border-radius: 12px;
            border: 1px solid var(--border-color);
            width: 280px;
            z-index: 10;
            box-shadow: 0 15px 35px rgba(0,0,0,0.25);
        }
        
        .setting {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .setting label {
            color: var(--text-secondary);
            font-size: 0.85rem;
            letter-spacing: 0.5px;
            text-transform: uppercase;
        }

        .setting input[type="color"] {
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
            width: 30px;
            height: 30px;
            border: none;
            border-radius: 50%;
            cursor: pointer;
            background: none;
        }
        .setting input[type="color"]::-webkit-color-swatch-wrapper { padding: 0; }
        .setting input[type="color"]::-webkit-color-swatch { border: 1px solid var(--border-color); border-radius: 50%;}
        
        .setting select {
            background: var(--bg-primary);
            color: var(--text-primary);
            border: 1px solid var(--border-color);
            padding: 0.5rem;
            border-radius: 6px;
            cursor: pointer;
            width: 150px;
        }

        .main-content-wrapper {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            justify-content: center; /* Center content vertically */
            align-items: center;
            width: 100%;
            max-width: 900px;
        }

        .typing-area {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            gap: 1rem;
            width: 100%;
        }

        /* --- STATS --- */
        .stats {
            display: flex;
            gap: 2.5rem;
            justify-content: center;
            margin-bottom: 2rem; /* Give space between stats and mode controls */
            transition: opacity 0.3s ease, visibility 0.3s ease, transform 0.3s ease;
            height: 60px; /* Increased height for better spacing */
            transform: translateY(20px);
        }
        
        .stats.hidden {
            opacity: 0;
            visibility: hidden;
            transform: translateY(0px);
        }

        .stat {
            background: none;
            padding: 0;
            text-align: center;
            min-width: 80px;
        }

        .stat-value {
            font-size: 1.5rem; /* Larger value */
            font-weight: 600;
            color: var(--accent-color);
        }

        .stat-label {
            font-size: 0.75rem; /* Smaller label */
            color: var(--text-secondary);
            margin-top: 0.25rem;
            letter-spacing: 1px;
            text-transform: uppercase;
        }

        /* --- TEST MODE CONTROLS --- */
        .test-mode-controls {
            display: flex;
            align-items: center;
            background-color: var(--bg-secondary);
            padding: 0.5rem;
            border-radius: 8px;
            gap: 0.5rem;
            margin-bottom: 2rem;
            transition: all 0.3s ease;
        }

        .test-mode-controls.hidden {
            opacity: 0;
            visibility: hidden;
            transform: scale(0.95);
        }
        
        .mode-group {
            display: flex;
            gap: 0.5rem;
            align-items: center;
        }
        
        /* Removed dividers for a cleaner look */
        .mode-divider {
            display: none;
        }

        .mode-btn {
            background: none;
            color: var(--text-secondary);
            border: none;
            padding: 0.5rem 1rem; /* More padding */
            border-radius: 6px;
            font-size: 0.9rem;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .mode-btn:hover {
            color: var(--text-primary);
            background-color: rgba(255, 255, 255, 0.05);
        }

        .mode-btn.active, .toggle-btn.active {
            color: var(--bg-primary);
            background-color: var(--accent-color);
        }
        
        .mode-btn.active:hover, .toggle-btn.active:hover {
             background-color: var(--accent-color);
             filter: brightness(1.1);
        }

        .mode-btn svg, .toggle-btn svg {
            width: 16px;
            height: 16px;
            fill: currentColor;
        }
        
        /* IN-TEST STATS (Progress Bar) */
        .in-test-stats {
            color: var(--text-muted);
            font-family: var(--main-font);
            font-size: 1rem; /* Larger for better visibility */
            height: 24px;
            margin-bottom: 1rem;
            transition: opacity 0.3s ease;
        }

        .in-test-stats.hidden {
            opacity: 0;
        }

        /* --- TEXT DISPLAY --- */
        .text-display {
            background: none;
            border: none;
            padding: 0;
            width: 100%;
            font-size: 1.8rem; /* Slightly smaller for balance */
            line-height: 2; /* Increased for zen/readability */
            font-family: var(--main-font);
            overflow: hidden; 
            max-height: 175px; /* Adjust based on new line-height */
            position: relative;
        }

        /* Fading effect for multi-line text */
        .text-display.static-fade::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 50%;
            background: linear-gradient(to bottom, transparent 0%, var(--bg-primary) 90%);
            pointer-events: none;
        }

        .text-content-wrapper {
            transition: transform 0.2s ease-out;
        }
        
        .text-content-wrapper.static {
            white-space: normal;
        }
        
        .text-content-wrapper.scroll {
              white-space: nowrap;
        }

        .word {
            display: inline-block;
        }

        .char {
            position: relative;
            transition: all 0.2s ease;
            color: var(--text-secondary); /* Un-typed text is now more muted */
        }

        .char.correct { color: var(--text-primary); } /* Correct is the default primary text color */
        .char.incorrect { color: var(--incorrect-color); text-decoration: underline; text-decoration-thickness: 2px;}
        .char.incorrect.space { background-color: rgba(248, 113, 113, 0.15); border-radius: 4px; }
        .char.current { 
            background: var(--accent-color); 
            color: var(--bg-primary); 
            border-radius: 4px; 
        }
        .loading-animation { color: var(--text-secondary); font-style: italic; padding: 1rem; }

        /* --- RESTART BUTTON --- */
        .restart-btn {
            background: none;
            border: none;
            color: var(--text-secondary);
            font-size: 1.5rem;
            cursor: pointer;
            transition: all 0.3s ease;
            margin-top: 2rem;
            opacity: 0;
            visibility: hidden;
            height: 0;
            transform: scale(0.9);
        }
        
        .restart-btn.visible {
            opacity: 1;
            visibility: visible;
            height: auto;
            transform: scale(1);
        }
        
        /* Removed rotation for a calmer effect */
        .restart-btn:hover {
            color: var(--accent-color);
            transform: scale(1.1);
        }
        
        /* Focus state for tab navigation */
        .restart-btn:focus-visible {
            outline: 2px solid var(--accent-color);
            outline-offset: 4px;
            border-radius: 50%;
            color: var(--accent-color);
        }

        .restart-btn svg {
            width: 28px;
            height: 28px;
            fill: currentColor;
        }
        

        /* --- KEYBOARD --- */
        .keyboard {
            width: 100%;
            max-width: 900px; /* Match main content */
            padding: 0.5rem 0 1rem 0;
            transition: opacity 0.3s ease, visibility 0.3s ease, height 0.3s ease, padding 0.3s ease, margin 0.3s ease;
        }

        .keyboard.hidden {
            opacity: 0;
            visibility: hidden;
            height: 0;
            padding: 0;
            margin: 0;
            overflow: hidden;
        }

        .keyboard-row {
            display: flex;
            justify-content: center;
            gap: 0.5rem; 
            margin-bottom: 0.5rem;
        }

        .key-gap {
             width: calc(var(--key-unit-width) * 2);
             flex-shrink: 0;
        }

        .key {
            background-color: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-bottom-width: 3px; /* Subtle 3D effect */
            border-radius: 6px;
            height: calc(var(--key-unit-width) * 1.1);
            display: flex; align-items: center; justify-content: center;
            font-size: 0.8rem;
            color: var(--text-secondary);
            transition: all 0.1s ease;
            cursor: default;
            font-family: var(--main-font);
            flex-shrink: 0;
        }

        .key.pressed {
            background: var(--accent-color); color: var(--bg-primary);
            border-color: var(--accent-color); 
            transform: translateY(2px); /* Press down effect */
            border-bottom-width: 1px;
        }
        
        .u-100 { width: var(--key-unit-width); }
        .u-125 { width: calc(var(--key-unit-width) * 1.25); }
        .u-150 { width: calc(var(--key-unit-width) * 1.5); }
        .u-175 { width: calc(var(--key-unit-width) * 1.75); }
        .u-200 { width: calc(var(--key-unit-width) * 2.0); }
        .u-225 { width: calc(var(--key-unit-width) * 2.25); }
        .u-275 { width: calc(var(--key-unit-width) * 2.75); }
        .u-625 { width: calc(var(--key-unit-width) * 6.25); }
        .u-space-split-left { width: calc(var(--key-unit-width) * 2.75); }
        .u-space-split-right { width: calc(var(--key-unit-width) * 3.5); }

        .key .special-text { font-size: 0.65rem; }
        
        @media (max-width: 900px) {
            :root { --key-unit-width: 2rem; }
            .text-display { font-size: 1.6rem; }
        }

        @media (max-width: 768px) {
            .container { padding: 1rem; }
             :root { --key-unit-width: 1.5rem; }
            .settings-area { top: 1rem; right: 1rem; }
            .stats { gap: 1.5rem; }
            .test-mode-controls {
                flex-wrap: wrap;
                justify-content: center;
            }
        }
         @media (max-width: 480px) {
             :root { --key-unit-width: 1rem; }
             .key .special-text { display: none; }
             .text-display { font-size: 1.4rem; }
         }

    </style>
</head>
<body>
    <div class="container">
        <div class="settings-area">
             <!-- Replaced emoji with a cleaner SVG icon -->
            <button class="settings-btn" id="settingsBtn">
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19.479,10.092,17.2,12.37,19.479,14.65a1,1,0,0,0,1.414-1.414L18.62,12.37l2.273-2.273a1,1,0,0,0-1.414-1.414Zm-4.9,4.9a1,1,0,0,0-1.414,1.414l2.273,2.273-2.273,2.273a1,1,0,0,0,1.414,1.414L17.2,19.489l2.273,2.273a1,1,0,0,0,1.414-1.414L18.62,18.076Zm-10.024-5a1,1,0,0,0-1.414-1.414L.868,12.37,3.141,14.65a1,1,0,0,0,1.414-1.414L2.282,12.37l2.273-2.273ZM6.828,18.076,4.555,15.8a1,1,0,0,0-1.414,1.414L5.414,19.489.868,24.035a1,1,0,0,0,1.414,1.414l4.546-4.546-2.273-2.273A1,1,0,0,0,6.828,18.076ZM12.035.868,7.489,5.414,9.762,7.687a1,1,0,1,0,1.414-1.414L8.9,3.993l4.546-4.546A1,1,0,0,0,12.035.868Z"/></svg>
            </button>
            <div class="settings-panel" id="settingsPanel">
                 <div class="setting">
                     <label for="accentColor">Theme</label>
                     <input type="color" id="accentColor" value="#2dd4bf">
                 </div>
                 <div class="setting">
                     <label for="textDisplayMode">Text Display</label>
                     <select id="textDisplayMode">
                         <option value="static">Static</option>
                         <option value="scroll">Scroll</option>
                     </select>
                 </div>
                 <div class="setting">
                     <label for="keyboardType">Keyboard</label>
                     <select id="keyboardType">
                         <option value="hidden">Hidden</option>
                         <option value="full">Full</option>
                         <option value="no-numrow">No Numrow</option>
                         <option value="split">Split</option>
                     </select>
                 </div>
                 <div class="setting">
                     <label for="fontType">Font</label>
                     <select id="fontType">
                         <option value="'Roboto Mono', monospace">Roboto Mono</option>
                         <option value="'Courier Prime', monospace">Courier Prime</option>
                         <option value="'Source Code Pro', monospace">Source Code Pro</option>
                     </select>
                 </div>
                 <div class="setting">
                     <label for="codingLanguage">Language</label>
                     <select id="codingLanguage">
                         <option value="python">Python</option>
                         <option value="javascript">JavaScript</option>
                         <option value="java">Java</option>
                         <option value="c++">C++</option>
                         <option value="rust">Rust</option>
                     </select>
                 </div>
            </div>
        </div>

        <div class="main-content-wrapper">
             <div class="stats hidden" id="stats">
                 <div class="stat">
                     <div class="stat-value" id="wpm">0</div>
                     <div class="stat-label">WPM</div>
                 </div>
                 <div class="stat">
                     <div class="stat-value" id="accuracy">100%</div>
                     <div class="stat-label">Accuracy</div>
                 </div>
                 <div class="stat">
                     <div class="stat-value" id="time">0s</div>
                     <div class="stat-label">Time</div>
                 </div>
             </div>
            
             <div class="test-mode-controls" id="testModeControls">
                 <div class="mode-group" id="extraOptionsGroup">
                 </div>
                 <div class="mode-group" id="primaryModeGroup">
                 </div>
                 <div class="mode-group" id="secondaryModeGroup">
                 </div>
             </div>

             <div class="typing-area">
                 <div class="in-test-stats hidden" id="inTestStats"></div>
                 <div class="text-display" id="textDisplayContainer">
                     <div class="text-content-wrapper" id="textContentWrapper">
                     </div>
                 </div>
                 <button class="restart-btn" id="restartBtn" tabindex="-1">
                     <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16">
                         <path fill-rule="evenodd" d="M8 3a5 5 0 1 0 4.546 2.914.5.5 0 0 1 .908-.417A6 6 0 1 1 8 2z"/>
                         <path d="M8 4.466V.534a.25.25 0 0 1 .41-.192l2.36 1.966c.12.1.12.284 0 .384L8.41 4.658A.25.25 0 0 1 8 4.466"/>
                     </svg>
                 </button>
             </div>
        </div>


        <div class="keyboard hidden" id="keyboard">
        </div>
    </div>

    <script>
        // --- DOM Elements ---
        const textDisplayContainer = document.getElementById('textDisplayContainer');
        const textContentWrapper = document.getElementById('textContentWrapper');
        const statsContainer = document.getElementById('stats');
        const wpmDisplay = document.getElementById('wpm');
        const accuracyDisplay = document.getElementById('accuracy');
        const timeDisplay = document.getElementById('time');
        const settingsBtn = document.getElementById('settingsBtn');
        const settingsPanel = document.getElementById('settingsPanel');
        const modeControls = document.getElementById('testModeControls');
        const extraOptionsGroup = document.getElementById('extraOptionsGroup');
        const primaryModeGroup = document.getElementById('primaryModeGroup');
        const secondaryModeGroup = document.getElementById('secondaryModeGroup');
        const keyboardContainer = document.getElementById('keyboard');
        const accentColorPicker = document.getElementById('accentColor');
        const textDisplaySelect = document.getElementById('textDisplayMode');
        const keyboardTypeSelect = document.getElementById('keyboardType');
        const fontTypeSelect = document.getElementById('fontType');
        const codingLanguageSelect = document.getElementById('codingLanguage');
        const restartBtn = document.getElementById('restartBtn');
        const inTestStats = document.getElementById('inTestStats');

        // --- Data & State ---
        const wordList = ["the", "be", "to", "of", "and", "a", "in", "that", "have", "I", "it", "for", "not", "on", "with", "he", "as", "you", "do", "at", "this", "but", "his", "by", "from", "they", "we", "say", "her", "she", "or", "an", "will", "my", "one", "all", "would", "there", "their", "what", "so", "up", "out", "if", "about", "who", "get", "which", "go", "me", "when", "make", "can", "like", "time", "no", "just", "him", "know", "take", "person", "into", "year", "your", "good", "some", "could", "them", "see", "other", "than", "then", "now", "look", "only", "come", "its", "over", "think", "also", "back", "after", "use", "two", "how", "our", "work", "first", "well", "way", "even", "new", "want", "because", "any", "these", "give", "day", "most", "us"];
        const premadeQuotes = {
            short: [
                "The only way to do great work is to love what you do.",
                "The journey of a thousand miles begins with a single step.",
                "That which does not kill us makes us stronger.",
                "Be yourself; everyone else is already taken."
            ],
            medium: [
                "Success is not final, failure is not fatal: it is the courage to continue that counts.",
                "The future belongs to those who believe in the beauty of their dreams.",
                "It is our choices, Harry, that show what we truly are, far more than our abilities.",
                "The two most important days in your life are the day you are born and the day you find out why."
            ],
            long: [
                "In three words I can sum up everything I've learned about life: it goes on.",
                "To be yourself in a world that is constantly trying to make you something else is the greatest accomplishment.",
                "I have not failed. I've just found 10,000 ways that won't work. Many of life's failures are people who did not realize how close they were to success when they gave up."
            ]
        };
        const premadeCodeSnippets = {
            python: {
                variables: [`name = "Alice"`, `age = 30`, `is_active = True`, `items = [1, 2, 3]`],
                loops: [`for i in range(5):\n  print(i)`, `while count < 5:\n  count += 1`],
                functions: [`def greet(name):\n  return f"Hello, {name}"`, `def add(a, b):\n  return a + b`]
            },
            javascript: {
                variables: [`let name = "Bob";`, `const score = 100;`, `let isActive = false;`, `const items = [1, 2, 3];`],
                loops: [`for (let i = 0; i < 5; i++) {\n  console.log(i);\n}`, `items.forEach(item => {\n  console.log(item);\n});`],
                functions: [`const greet = (name) => {\n  return \`Hello, \${name}\`;\n}`, `function multiply(a, b) {\n  return a * b;\n}`]
            },
            java: {
                variables: [`String name = "Charles";`, `int version = 11;`, `boolean isComplete = true;`],
                loops: [`for (int i = 0; i < 5; i++) {\n  System.out.println(i);\n}`],
                functions: [`public String greet(String name) {\n  return "Hello, " + name;\n}`]
            },
            'c++': {
                variables: [`std::string name = "Diana";`, `int score = 95;`],
                loops: [`for (int i = 0; i < 5; ++i) {\n  std::cout << i << std::endl;\n}`],
                functions: [`int add(int a, int b) {\n  return a + b;\n}`]
            },
            rust: {
                variables: [`let name = "Eve";`, `let mut count = 0;`],
                loops: [`for i in 0..5 {\n  println!("{}", i);\n}`],
                functions: [`fn greet(name: &str) -> String {\n  format!("Hello, {}", name)\n}`]
            }
        };
        const punctuationList = ['.', ',', ';', "'", '?', '!'];

        const layouts = {
             full: [[{t:'`',k:'Backquote',s:'u-100'},{t:'1',k:'Digit1',s:'u-100'},{t:'2',k:'Digit2',s:'u-100'},{t:'3',k:'Digit3',s:'u-100'},{t:'4',k:'Digit4',s:'u-100'},{t:'5',k:'Digit5',s:'u-100'},{t:'6',k:'Digit6',s:'u-100'},{t:'7',k:'Digit7',s:'u-100'},{t:'8',k:'Digit8',s:'u-100'},{t:'9',k:'Digit9',s:'u-100'},{t:'0',k:'Digit0',s:'u-100'},{t:'-',k:'Minus',s:'u-100'},{t:'=',k:'Equal',s:'u-100'},{t:'Backspace',k:'Backspace',s:'u-200'}],[{t:'Tab',k:'Tab',s:'u-150'},{t:'q',k:'KeyQ',s:'u-100'},{t:'w',k:'KeyW',s:'u-100'},{t:'e',k:'KeyE',s:'u-100'},{t:'r',k:'KeyR',s:'u-100'},{t:'t',k:'KeyT',s:'u-100'},{t:'y',k:'KeyY',s:'u-100'},{t:'u',k:'KeyU',s:'u-100'},{t:'i',k:'KeyI',s:'u-100'},{t:'o',k:'KeyO',s:'u-100'},{t:'p',k:'KeyP',s:'u-100'},{t:'[',k:'BracketLeft',s:'u-100'},{t:']',k:'BracketRight',s:'u-100'},{t:'\\',k:'Backslash',s:'u-150'}],[{t:'Caps Lock',k:'CapsLock',s:'u-175'},{t:'a',k:'KeyA',s:'u-100'},{t:'s',k:'KeyS',s:'u-100'},{t:'d',k:'KeyD',s:'u-100'},{t:'f',k:'KeyF',s:'u-100'},{t:'g',k:'KeyG',s:'u-100'},{t:'h',k:'KeyH',s:'u-100'},{t:'j',k:'KeyJ',s:'u-100'},{t:'k',k:'KeyK',s:'u-100'},{t:'l',k:'KeyL',s:'u-100'},{t:';',k:'Semicolon',s:'u-100'},{t:'\'',k:'Quote',s:'u-100'},{t:'Enter',k:'Enter',s:'u-225'}],[{t:'Shift',k:'ShiftLeft',s:'u-225'},{t:'z',k:'KeyZ',s:'u-100'},{t:'x',k:'KeyX',s:'u-100'},{t:'c',k:'KeyC',s:'u-100'},{t:'v',k:'KeyV',s:'u-100'},{t:'b',k:'KeyB',s:'u-100'},{t:'n',k:'KeyN',s:'u-100'},{t:'m',k:'KeyM',s:'u-100'},{t:',',k:'Comma',s:'u-100'},{t:'.',k:'Period',s:'u-100'},{t:'/',k:'Slash',s:'u-100'},{t:'Shift',k:'ShiftRight',s:'u-275'}],[{t:'Ctrl',k:'ControlLeft',s:'u-125'},{t:'Alt',k:'AltLeft',s:'u-125'},{t:' ',k:'Space',s:'u-625'},{t:'Alt',k:'AltRight',s:'u-125'},{t:'Ctrl',k:'ControlRight',s:'u-125'}]],
             'no-numrow': [[{t:'Tab',k:'Tab',s:'u-150'},{t:'q',k:'KeyQ',s:'u-100'},{t:'w',k:'KeyW',s:'u-100'},{t:'e',k:'KeyE',s:'u-100'},{t:'r',k:'KeyR',s:'u-100'},{t:'t',k:'KeyT',s:'u-100'},{t:'y',k:'KeyY',s:'u-100'},{t:'u',k:'KeyU',s:'u-100'},{t:'i',k:'KeyI',s:'u-100'},{t:'o',k:'KeyO',s:'u-100'},{t:'p',k:'KeyP',s:'u-100'},{t:'[',k:'BracketLeft',s:'u-100'},{t:']',k:'BracketRight',s:'u-100'},{t:'\\',k:'Backslash',s:'u-150'}],[{t:'Caps Lock',k:'CapsLock',s:'u-175'},{t:'a',k:'KeyA',s:'u-100'},{t:'s',k:'KeyS',s:'u-100'},{t:'d',k:'KeyD',s:'u-100'},{t:'f',k:'KeyF',s:'u-100'},{t:'g',k:'KeyG',s:'u-100'},{t:'h',k:'KeyH',s:'u-100'},{t:'j',k:'KeyJ',s:'u-100'},{t:'k',k:'KeyK',s:'u-100'},{t:'l',k:'KeyL',s:'u-100'},{t:';',k:'Semicolon',s:'u-100'},{t:'\'',k:'Quote',s:'u-100'},{t:'Enter',k:'Enter',s:'u-225'}],[{t:'Shift',k:'ShiftLeft',s:'u-225'},{t:'z',k:'KeyZ',s:'u-100'},{t:'x',k:'KeyX',s:'u-100'},{t:'c',k:'KeyC',s:'u-100'},{t:'v',k:'KeyV',s:'u-100'},{t:'b',k:'KeyB',s:'u-100'},{t:'n',k:'KeyN',s:'u-100'},{t:'m',k:'KeyM',s:'u-100'},{t:',',k:'Comma',s:'u-100'},{t:'.',k:'Period',s:'u-100'},{t:'/',k:'Slash',s:'u-100'},{t:'Shift',k:'ShiftRight',s:'u-275'}],[{t:'Ctrl',k:'ControlLeft',s:'u-125'},{t:'Alt',k:'AltLeft',s:'u-125'},{t:' ',k:'Space',s:'u-625'},{t:'Alt',k:'AltRight',s:'u-125'},{t:'Ctrl',k:'ControlRight',s:'u-125'}]],
             split: [[{t:'Esc',k:'Escape',s:'u-100'},{t:'Q',k:'KeyQ',s:'u-100'},{t:'W',k:'KeyW',s:'u-100'},{t:'E',k:'KeyE',s:'u-100'},{t:'R',k:'KeyR',s:'u-100'},{t:'T',k:'KeyT',s:'u-100'},{t:'gap'},{t:'Y',k:'KeyY',s:'u-100'},{t:'U',k:'KeyU',s:'u-100'},{t:'I',k:'KeyI',s:'u-100'},{t:'O',k:'KeyO',s:'u-100'},{t:'P',k:'KeyP',s:'u-100'},{t:'Backspace',k:'Backspace',s:'u-150'}],[{t:'Tab',k:'Tab',s:'u-150'},{t:'A',k:'KeyA',s:'u-100'},{t:'S',k:'KeyS',s:'u-100'},{t:'D',k:'KeyD',s:'u-100'},{t:'F',k:'KeyF',s:'u-100'},{t:'G',k:'KeyG',s:'u-100'},{t:'gap'},{t:'H',k:'KeyH',s:'u-100'},{t:'J',k:'KeyJ',s:'u-100'},{t:'K',k:'KeyK',s:'u-100'},{t:'L',k:'KeyL',s:'u-100'},{t:';',k:'Semicolon',s:'u-100'},{t:'\'',k:'Quote',s:'u-125'}],[{t:'Shift',k:'ShiftLeft',s:'u-175'},{t:'Z',k:'KeyZ',s:'u-100'},{t:'X',k:'KeyX',s:'u-100'},{t:'C',k:'KeyC',s:'u-100'},{t:'V',k:'KeyV',s:'u-100'},{t:'B',k:'KeyB',s:'u-100'},{t:'gap'},{t:'N',k:'KeyN',s:'u-100'},{t:'M',k:'KeyM',s:'u-100'},{t:',',k:'Comma',s:'u-100'},{t:'.',k:'Period',s:'u-100'},{t:'/',k:'Slash',s:'u-100'},{t:'Shift',k:'ShiftRight',s:'u-175'}],[{t:'Ctrl',k:'ControlLeft',s:'u-125'},{t:'Alt',k:'AltLeft',s:'u-125'},{t:' ',k:'Space',s:'u-275'},{t:'gap'},{t:' ',k:'Space',s:'u-275'},{t:'Enter',k:'Enter',s:'u-125'},{t:'Alt',k:'AltRight',s:'u-125'}]]
        };

        const modeOptions = {
            time: [15, 30, 60, 120],
            words: [10, 25, 50, 100],
            quote: ['short', 'medium', 'long'],
            code: ['variables', 'loops', 'functions']
        };

        let keyMap = {};
        let originalText = '';
        let typedText = '';
        let isTestActive = false;
        let isPaused = false;
        let isTestComplete = false;
        let startTime = null;
        let statTimer = null;
        let inactivityTimer = null;
        let generationId = 0;
        let totalCharsTyped = 0;
        let totalErrors = 0;
        let testConfig = {
            mode: 'words', 
            value: 25,
            includePunctuation: false,
            includeNumbers: false
        };

        // --- Core Functions ---
        const generateWords = (count) => {
            let words = new Array(count).fill(null).map(() => wordList[Math.floor(Math.random() * wordList.length)]);
            
            if(testConfig.includePunctuation) {
                words = words.map((word, index) => {
                    if(Math.random() < 0.25 && index < words.length -1) {
                        return word + punctuationList[Math.floor(Math.random() * punctuationList.length)];
                    }
                    return word;
                });
            }

            if(testConfig.includeNumbers) {
                 for (let i = 0; i < count * 0.2; i++) {
                    const randomIndex = Math.floor(Math.random() * words.length);
                    const randomNumber = Math.floor(Math.random() * 1000).toString();
                    words.splice(randomIndex, 0, randomNumber);
                 }
            }

            return words.join(' ');
        };

        const startTest = async () => {
            const thisGenerationId = ++generationId;
            await resetTest(thisGenerationId); 
            if (thisGenerationId !== generationId) return;

            isTestActive = true;
            const { mode, value } = testConfig;
            let newText = '';

            if (mode === 'time') {
                newText = generateWords(100); 
            } else if (mode === 'words') {
                 newText = generateWords(value);
            } else if (mode === 'quote') {
                const quoteCategory = premadeQuotes[value] || premadeQuotes.short;
                newText = quoteCategory[Math.floor(Math.random() * quoteCategory.length)];
            } else if (mode === 'code') {
                const lang = codingLanguageSelect.value;
                const snippetsForLang = premadeCodeSnippets[lang] || premadeCodeSnippets.javascript;
                const snippetCategory = snippetsForLang[value] || snippetsForLang.variables;
                newText = snippetCategory[Math.floor(Math.random() * snippetCategory.length)];
            }
            
            if (thisGenerationId !== generationId) return;
            originalText = newText;
            renderText();
        }

        const resetTest = async (callerGenerationId) => {
            if (callerGenerationId && callerGenerationId !== generationId) {
                return;
            }
            if (statTimer) clearInterval(statTimer);
            if (inactivityTimer) clearTimeout(inactivityTimer);
            
            isTestActive = false;
            isPaused = false;
            isTestComplete = false;
            originalText = '';
            typedText = '';
            startTime = null;
            statTimer = null;
            inactivityTimer = null;
            totalCharsTyped = 0;
            totalErrors = 0;
            
            textContentWrapper.innerHTML = `<div class="word"><span class="char">Select a mode to begin.</span></div>`;
            wpmDisplay.textContent = '0';
            accuracyDisplay.textContent = '100%';
            timeDisplay.textContent = '0s';
            
            statsContainer.classList.add('hidden');
            inTestStats.classList.add('hidden');
            modeControls.classList.remove('hidden');
            restartBtn.classList.remove('visible');
            
            // --- Tab Focus Management ---
            // Make mode controls focusable again
            setControlsFocusable(true);
            restartBtn.tabIndex = -1;
            
            updateTextScroll();
        }

        const renderText = () => {
            textContentWrapper.innerHTML = '';
            originalText.split('').forEach((char, index) => {
                const charEl = document.createElement('span');
                charEl.className = 'char';
                charEl.textContent = char;

                if (index < typedText.length) {
                    const typedChar = typedText[index];
                    charEl.classList.add(char === typedChar ? 'correct' : 'incorrect');
                    if (char === ' ' && char !== typedChar) {
                        charEl.classList.add('space');
                    }
                }

                if (index === typedText.length) {
                    charEl.classList.add('current');
                }

                if (char === ' ') {
                    charEl.innerHTML = '&nbsp;';
                }

                if (textDisplaySelect.value === 'static') {
                    const lastWord = textContentWrapper.lastChild && textContentWrapper.lastChild.classList.contains('word') ? textContentWrapper.lastChild : null;
                    if (char !== ' ' && lastWord) {
                        lastWord.appendChild(charEl);
                    } else {
                        const wordEl = document.createElement('div');
                        wordEl.className = 'word';
                        wordEl.appendChild(charEl);
                        textContentWrapper.appendChild(wordEl);
                    }
                } else {
                    textContentWrapper.appendChild(charEl);
                }
            });
            updateTextScroll();
        };

        const updateTextScroll = () => {
             const isStatic = textDisplaySelect.value === 'static';
             textDisplayContainer.classList.toggle('static-fade', isStatic && textContentWrapper.scrollHeight > textDisplayContainer.clientHeight);
            
             textContentWrapper.classList.toggle('static', isStatic);
             textContentWrapper.classList.toggle('scroll', !isStatic);


            const currentLetter = textContentWrapper.querySelector('.char.current');
            if (!currentLetter) {
                 textContentWrapper.style.transform = 'translateY(0px)';
                return;
            };

            if (isStatic) {
                const lineHeight = currentLetter.offsetHeight;
                const scrollOffset = currentLetter.offsetTop;
                // Start scrolling when the current line is past the first line
                if (scrollOffset >= lineHeight) {
                     // We subtract one line height to keep the current line visible
                    textContentWrapper.style.transform = `translateY(-${scrollOffset - lineHeight}px)`;
                } else {
                    textContentWrapper.style.transform = 'translateY(0px)';
                }
            } else { // scroll mode
                const containerCenter = textDisplayContainer.offsetWidth / 2;
                const letterOffset = currentLetter.offsetLeft + currentLetter.offsetWidth / 2;
                const scrollAmount = containerCenter - letterOffset;
                textContentWrapper.style.transform = `translateX(${scrollAmount}px)`;
            }
        }
        
        const updateInTestStats = () => {
             if (!isTestActive || typedText.length === 0) {
                 inTestStats.textContent = '';
                 return;
             };

            let wordsTyped = 0;
            const totalWordsInOriginal = originalText.trim().split(/\s+/).length;

            if(typedText.length > 0) {
                const typedWordsArray = typedText.trim().split(/\s+/);
                wordsTyped = typedWordsArray.length;
                // Don't count the current word until a space is typed
                if(originalText[typedText.length-1] !== ' ' && typedText.length < originalText.length) {
                    wordsTyped--;
                }
            }
            
            // Ensure final count is accurate
            if (typedText.length >= originalText.length) {
                wordsTyped = totalWordsInOriginal;
            }

            let statsHtml = '';
            const { mode, value } = testConfig;

            if (mode === 'time') {
                statsHtml = `words: ${wordsTyped}`;
            } else if (mode === 'words') {
                statsHtml = `${wordsTyped} / ${value}`;
            } else if (mode === 'quote' || mode === 'code') {
                statsHtml = `${wordsTyped} / ${totalWordsInOriginal}`;
            }
            inTestStats.textContent = statsHtml;
        }


        const updateStats = () => {
            if (!startTime || isPaused) return;
            const elapsed = (Date.now() - startTime) / 1000;
            const minutes = elapsed / 60;

            if (testConfig.mode === 'time') {
                const remaining = testConfig.value - elapsed;
                timeDisplay.textContent = `${Math.ceil(remaining)}s`;
                if (remaining <= 0) {
                    completeTest();
                }
            } else {
                 timeDisplay.textContent = `${Math.round(elapsed)}s`;
            }

            const correctChars = typedText.split('').filter((char, index) => char === originalText[index]).length;
            const wpm = minutes > 0 ? Math.round((correctChars / 5) / minutes) : 0;
            const accuracy = totalCharsTyped > 0 ? Math.round(((totalCharsTyped - totalErrors) / totalCharsTyped) * 100) : 100;
            
            wpmDisplay.textContent = wpm;
            accuracyDisplay.textContent = `${accuracy}%`;
            updateInTestStats();
        }
        
        const pauseTest = () => {
            if (!isTestActive || isPaused || isTestComplete) return;
            isPaused = true;
            if (statTimer) clearInterval(statTimer);
            if (inactivityTimer) clearTimeout(inactivityTimer);

            modeControls.classList.remove('hidden');
            restartBtn.classList.add('visible');

            // --- Tab Focus Management ---
            // Make only the restart button focusable
            setControlsFocusable(false);
            restartBtn.tabIndex = 0;
        }
        
        const resumeTest = () => {
            if (!isPaused) return;
            isPaused = false;
            inactivityTimer = setTimeout(pauseTest, 5000); // 5 second inactivity timeout

            modeControls.classList.add('hidden');
            restartBtn.classList.remove('visible');

            // --- Tab Focus Management ---
            setControlsFocusable(true);
            restartBtn.tabIndex = -1;
        }

        const handleKeyPress = async (e) => {
            const ignoredKeys = ['Shift', 'CapsLock', 'Control', 'Alt', 'Meta', 'ArrowLeft', 'ArrowRight', 'ArrowUp', 'ArrowDown'];
            
            // --- Tab Key Logic ---
            if (e.key === 'Tab') {
                e.preventDefault();
                // If the restart button is visible (test is paused or complete), focus it
                if (restartBtn.classList.contains('visible')) {
                    restartBtn.focus();
                } else {
                    // Otherwise, pause the test, which will make the button visible and focusable
                    pauseTest();
                    // Use a timeout to ensure the element is focusable before trying to focus it
                    setTimeout(() => restartBtn.focus(), 0);
                }
                return;
            }

            if (isPaused) {
                if(e.key.length === 1 && !e.ctrlKey && !e.metaKey){
                    resumeTest();
                } else {
                    return;
                }
            }
            
            if (ignoredKeys.includes(e.key) || isTestComplete) return;
            
            if (!isTestActive) {
                // Start test on any character key press
                if (e.key.length === 1) { 
                    await startTest();
                } else {
                    return;
                }
            }

            // Pause on Escape key
            if (e.key === 'Escape') {
                e.preventDefault();
                pauseTest();
                return;
            }
            
            // First valid keypress starts the timer
            if (typedText.length === 0 && startTime === null && e.key !== 'Backspace') {
                startTime = Date.now();
                statTimer = setInterval(updateStats, 100);
                statsContainer.classList.remove('hidden');
                inTestStats.classList.remove('hidden');
                modeControls.classList.add('hidden');
                restartBtn.classList.add('visible');
                // --- Tab Focus Management ---
                setControlsFocusable(false); // Make controls non-focusable during test
                restartBtn.tabIndex = 0; // Make restart button focusable
            }

            if (inactivityTimer) clearTimeout(inactivityTimer);
            inactivityTimer = setTimeout(pauseTest, 5000);

            pressKey(e.code);
            e.preventDefault();

            if (e.key === 'Backspace') {
                typedText = typedText.slice(0, -1);
            } else if (typedText.length < originalText.length && e.key.length === 1) {
                totalCharsTyped++;
                if (e.key !== originalText[typedText.length]) {
                    totalErrors++;
                }
                typedText += e.key;
            }

            renderText();
            updateStats();

            if (testConfig.mode !== 'time' && typedText.length >= originalText.length) {
                completeTest();
            }
        }

        const completeTest = () => {
            if (statTimer) clearInterval(statTimer);
            if (inactivityTimer) clearTimeout(inactivityTimer);
            
            isTestActive = false;
            isTestComplete = true;

            modeControls.classList.remove('hidden');
            restartBtn.classList.add('visible');
            statsContainer.classList.remove('hidden'); // Ensure final stats are visible

            // --- Tab Focus Management ---
            setControlsFocusable(true);
            restartBtn.tabIndex = 0;
            restartBtn.focus(); // Focus restart button on completion
        }
        
        // --- Tab Focus Helper ---
        const setControlsFocusable = (isFocusable) => {
            const controls = modeControls.querySelectorAll('button');
            controls.forEach(control => {
                control.tabIndex = isFocusable ? 0 : -1;
            });
        };

        const setMode = (mode, value) => {
            document.querySelectorAll('#primaryModeGroup .mode-btn').forEach(btn => btn.classList.remove('active'));
            const primaryBtn = document.querySelector(`.mode-btn[data-mode="${mode}"]`);
            if(primaryBtn) primaryBtn.classList.add('active');

            testConfig.mode = mode;
            updateSecondaryOptions(mode, value);
            startTest();
        }
        
        const updateSecondaryOptions = (mode, defaultValue) => {
            secondaryModeGroup.innerHTML = '';
            const options = modeOptions[mode];
            if (!options) return;

            options.forEach(option => {
                const btn = document.createElement('button');
                btn.className = 'mode-btn';
                btn.dataset.value = option;
                btn.textContent = option;
                btn.addEventListener('click', () => {
                    const val = btn.dataset.value;
                    testConfig.value = isNaN(parseInt(val)) ? val : parseInt(val);
                    document.querySelectorAll('#secondaryModeGroup .mode-btn').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    startTest();
                });
                secondaryModeGroup.appendChild(btn);
            });

            const defaultBtn = secondaryModeGroup.querySelector(`[data-value="${defaultValue}"]`) || secondaryModeGroup.firstChild;
            if(defaultBtn) {
                defaultBtn.classList.add('active');
                const val = defaultBtn.dataset.value;
                testConfig.value = isNaN(parseInt(val)) ? val : parseInt(val);
            }
        }


        // --- Settings and Keyboard Rendering ---
        const renderKeyboard = (layoutName) => {
            const layout = layouts[layoutName] || layouts.full;
            keyboardContainer.innerHTML = "";
            keyMap = {};
            layout.forEach(row => {
                const rowEl = document.createElement("div");
                rowEl.className = "keyboard-row";
                row.forEach(keyData => {
                    if (keyData.t === 'gap') {
                        const gapEl = document.createElement('div');
                        gapEl.className = `key-gap`;
                        rowEl.appendChild(gapEl);
                        return;
                    }

                    const keyEl = document.createElement("div");
                    keyEl.className = `key ${keyData.s}`;
                    keyEl.dataset.key = keyData.k;
                    if (keyData.t.length > 1 && keyData.t !== ' ') {
                        keyEl.innerHTML = `<span class="special-text">${keyData.t}</span>`;
                    } else {
                        keyEl.textContent = keyData.t;
                    }
                    rowEl.appendChild(keyEl);
                    keyMap[keyData.k] = keyEl;
                });
                keyboardContainer.appendChild(rowEl);
            });
        }
        const pressKey = (keyCode) => {
            const keyElement = keyMap[keyCode];
            if (keyElement) {
                keyElement.classList.add('pressed');
                setTimeout(() => keyElement.classList.remove('pressed'), 100);
            }
        }
        const setFont = (font) => document.documentElement.style.setProperty('--main-font', font);
        
        const initializeModeSelector = () => {
            const extraOptions = [
                {name: 'punctuation', icon: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M6,13H8V15H6V13M6,17H8V19H6V17M10,7H12V9H10V7M16,7H18V9H16V7M12,2A10,10 0 0,0 2,12A10,10 0 0,0 12,22A10,10 0 0,0 22,12A10,10 0 0,0 12,2M12,20C7.59,20 4,16.41 4,12C4,7.59 7.59,4 12,4C16.41,4 20,7.59 20,12C20,16.41 16.41,20 12,20Z"/></svg>'},
                {name: 'numbers', icon: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M4,2H6V22H4V2M10,2H12V22H10V2M16,2H18V22H16V2M22,2V22H20V2H22M8,2V22H14V14H8V12H14V4H8V2Z"/></svg>'}
            ];

            extraOptions.forEach(opt => {
                const btn = document.createElement('button');
                btn.className = 'mode-btn toggle-btn';
                btn.dataset.option = opt.name;
                btn.innerHTML = `${opt.icon} ${opt.name}`;
                btn.addEventListener('click', () => {
                    btn.classList.toggle('active');
                    testConfig.includePunctuation = document.querySelector('[data-option="punctuation"]').classList.contains('active');
                    testConfig.includeNumbers = document.querySelector('[data-option="numbers"]').classList.contains('active');
                    startTest();
                });
                extraOptionsGroup.appendChild(btn);
            });

            const primaryModes = [
                {name: 'time', icon: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12,2A10,10 0 0,0 2,12A10,10 0 0,0 12,22A10,10 0 0,0 22,12A10,10 0 0,0 12,2M16.2,16.2L11,13V7H12.5V12.2L17,14.9L16.2,16.2Z" /></svg>'},
                {name: 'words', icon: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M2,6L12,11L22,6V18A2,2 0 0,1 20,20H4A2,2 0 0,1 2,18V6M20,4H4C2.9,4 2,4.9 2,6V6H22V6C22,4.9 21.1,4 20,4Z" /></svg>'},
                {name: 'quote', icon: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M14,17H17L19,13V7H13V13H16M6,17H9L11,13V7H5V13H8L6,17Z" /></svg>'},
                {name: 'code', icon: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M7.4,6L2.4,11L7.4,16L6,17.4L-0.2,11L6,4.6L7.4,6M16.6,6L21.6,11L16.6,16L18,17.4L24.2,11L18,4.6L16.6,6Z" /></svg>'}
            ];

            primaryModeGroup.innerHTML = '';
            primaryModes.forEach(mode => {
                 const btn = document.createElement('button');
                 btn.className = 'mode-btn';
                 btn.dataset.mode = mode.name;
                 btn.innerHTML = `${mode.icon} ${mode.name}`;
                 btn.addEventListener('click', () => setMode(mode.name, modeOptions[mode.name][0]));
                 primaryModeGroup.appendChild(btn);
            });

             setMode(testConfig.mode, testConfig.value);
        }

        // --- Event Listeners ---
        settingsBtn.addEventListener('click', e => { 
            e.stopPropagation(); 
            const isOpen = settingsPanel.style.display === 'flex';
            settingsPanel.style.display = isOpen ? 'none' : 'flex';
            settingsBtn.classList.toggle('open', !isOpen);
        });
        document.addEventListener('click', e => { 
            if (!settingsPanel.contains(e.target) && !settingsBtn.contains(e.target)) {
                 settingsPanel.style.display = 'none';
                 settingsBtn.classList.remove('open');
            }
        });
        accentColorPicker.addEventListener('input', e => document.documentElement.style.setProperty('--accent-color', e.target.value));
        textDisplaySelect.addEventListener('change', () => {
            renderText();
            updateTextScroll();
        });
        keyboardTypeSelect.addEventListener('change', e => {
            const layout = e.target.value;
            keyboardContainer.classList.toggle('hidden', layout === 'hidden');
            if (layout !== 'hidden') {
                renderKeyboard(layout);
            }
        });
        codingLanguageSelect.addEventListener('change', () => {
            if (testConfig.mode === 'code') {
                startTest();
            }
        });
        fontTypeSelect.addEventListener('change', e => setFont(e.target.value));
        
        document.addEventListener('keydown', handleKeyPress);
        restartBtn.addEventListener('click', () => startTest());
        window.addEventListener('blur', pauseTest);
        window.addEventListener('resize', () => updateTextScroll());


        // --- Initial Load ---
        document.addEventListener('DOMContentLoaded', () => {
            initializeModeSelector();
            setFont(fontTypeSelect.value);
            const currentLayout = keyboardTypeSelect.value;
            keyboardContainer.classList.toggle('hidden', currentLayout === 'hidden');
             if (currentLayout !== 'hidden') {
                 renderKeyboard(currentLayout);
             }
            startTest();
        });
    </script>
</body>
</html>
